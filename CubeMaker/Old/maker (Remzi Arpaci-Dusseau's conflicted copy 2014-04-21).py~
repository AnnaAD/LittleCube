#! /usr/bin/env python

from Tkinter import *
from types import *
import math, random, time, sys, os, tempfile, copy
from subprocess import *
from optparse import OptionParser

#
# Utility functions
#
# there aren't many, and most of them are quite silly
#

# safely delete an item from the canvas (if it exists)
# assumes that deleted items are set to -1
# (generally used by setting the item to the return value here)
def SafeDelete(canvas, item):
    if item != -1:
        canvas.delete(item)
    return -1

# called when something is horribly wrong
def Abort(str):
    print 'ABORTING [%s]' % str
    exit(1)

# no-op
def Nop():
    nop = True

def Min(v1, v2):
    if v1 < v2:
        return v1
    else:
        return v2

def Between(x, x1, x2):
    if x > x1 and x < x2:
        return True
    elif x < x1 and x > x2:
        return True
    return False

def BoolToBit(b):
    if b == True:
        return 1
    else:
        return 0
    
#
# class Controller:
# 
# deal with all the button presses and things like that
# unfortunately, also right now is doing all the play definition stuff
# which you think would be done elsewhere...
# 
class Controller:
    def __init__(self, root, canvas, fieldPtr):
        self.root     = root
        self.canvas   = canvas
        self.fieldPtr = fieldPtr

        # mouse buttons: they are complicated and hence ...
        self.root.bind('<ButtonPress-1>',         self.LeftButtonPress)
        self.root.bind('<ButtonRelease-1>',       self.LeftButtonRelease)
        self.root.bind('<Shift-ButtonPress-1>',   self.ShiftLeftButtonPress)
        self.root.bind('<Shift-ButtonRelease-1>', self.ShiftLeftButtonRelease)
        self.root.bind('<ButtonPress-2>',         self.RightButtonPress)
        self.root.bind('<ButtonRelease-2>',       self.RightButtonRelease)
        self.root.bind('<Double-Button-1>',       self.DoubleClick)

        # other useful key bindings
        self.root.bind('1',                       self.Number1)
        self.root.bind('2',                       self.Number2)
        self.root.bind('3',                       self.Number3)
        self.root.bind('4',                       self.Number4)
        self.root.bind('5',                       self.Number5)
        self.root.bind('6',                       self.Number6)
        self.root.bind('Q',                       self.Exit)
        self.root.bind('h',                       self.Hike)
        self.root.bind('a',                       self.PlaybookUp)
        self.root.bind('z',                       self.PlaybookDown)
        self.root.bind('<Key-space>',             self.SelectPlay)
        self.root.bind('s',                       self.FormationUp)
        self.root.bind('x',                       self.FormationDown)
        self.root.bind('j',                       self.OtherPlaybookUp)
        self.root.bind('m',                       self.OtherPlaybookDown)
        self.root.bind('d',                       self.TogglePlayDefineMode)
        self.root.bind('c',                       self.CopyPlay)
        self.root.bind('v',                       self.PastePlay)
        self.root.bind('f',                       self.FlipPlay)
        self.root.bind('t',                       self.ToggleOffenseDefense)
        self.root.bind('p',                       self.Pause)
        self.root.bind('r',                       self.Replay)
        self.root.bind('<Escape>',                self.AbortPlayDefinition)

        # special: for mouse motion
        self.canvas.bind('<Motion>',              self.UpdateMouse)

        # where is the mouse?
        self.mouseX = 0
        self.mouseY = 0

        # get things ready for defining a play
        self.playMode = True

        # init the states of the play definition engine
        self.InitAll() 

        # and initial mode?
        self.root.after(3000, self.DrawMode)

    # Controller: SetPlaybookPtr()
    def SetPlaybookPtr(self, playbookPtr):
        self.playbookPtr = playbookPtr

    # Controller:
    def DrawMode(self):
        self.modeID = self.canvas.create_text(10, 10, anchor='w', text='mode: [Ready To Hike]', fill='orange', font=('courier', 20))

    # Controller:
    def AbortPlayDefinition(self, event):
        if self.gamePtr.IsPractice() == False:
            return
        if self.playMode == False:
            if self.mode == 'MODE_PLAYER_SELECTED':
                self.sourcePlayer.UndrawPlay()
                self.sourcePlayer.DrawPlay()
            self.ResetAll()

    # Controller:
    def SetBallPtr(self, ballPtr):
        self.ballPtr = ballPtr

    # Controller:
    def GetMouseX(self):
        return self.mouseX
               
    # Controller:
    def GetMouseY(self):
        return self.mouseY

    # Controller:
    def SetGamePtr(self, gamePtr):
        self.gamePtr = gamePtr

    def SetScoreboardPtr(self, scoreboardPtr):
        self.scoreboardPtr = scoreboardPtr

    # Controller:
    def SetModeToPlaying(self):
        self.canvas.bind('<Motion>', self.UpdateMouse)
        self.ResetAll()
        self.playMode = True
        SafeDelete(self.canvas, self.modeID)
        self.modeID = self.canvas.create_text(10, 10, anchor='w', text='mode: [Ready To Hike]', fill='orange', font=('courier', 20))
        for p in self.gamePtr.players:
            p.Unhilite()
        self.scoreboardPtr.UpdateControls()
                
    # Controller:
    def SetModeToDefining(self):
        self.canvas.bind('<Motion>', self.UpdateMousePlus)
        self.ResetAll()
        self.playMode = False
        SafeDelete(self.canvas, self.modeID)
        self.modeID = self.canvas.create_text(10, 10, anchor='w', text='mode: [Defining A Play]', fill='orange', font=('courier', 20))
        self.scoreboardPtr.UpdateControls()

    # Controller: 
    def InitAll(self):
        self.mode         = 'MODE_NO_PLAYER_SELECTED'
        self.hilite       = 'HILITE_NOT_IN_ANYTHING'

        self.lineID       = -1
        self.messageID    = -1
        self.boxID        = -1

        self.lineIDList   = []
        self.anchorPoint  = []
        self.behaviorList = []
        self.behaviorList = []
        self.ifStack      = []

    # Controller: 
    def DeleteAll(self):
        for line in self.lineIDList:
            SafeDelete(self.canvas, line)
        SafeDelete(self.canvas, self.lineID)
        SafeDelete(self.canvas, self.messageID)
        SafeDelete(self.canvas, self.boxID)

    # Controller: 
    # this should reset everything to the beginning state
    def ResetAll(self):
        self.DeleteAll()
        self.InitAll()

    # Controller: 
    # this is used when the play is not being defined
    # it is much more efficient than UpdateMousePlus(), which checks for lots and lots of things
    def UpdateMouse(self, event):
        self.mouseX = event.x
        self.mouseY = event.y

    # Controller: UpdateMousePlus()
    #
    # By running in this routine, it means that we are in play definition mode (not hike mode)
    # This is toggled by hitting the 'p' button
    #
    # States:
    # - MODE_NO_PLAYER_SELECTED: pick a player or define a box
    #   when over player, highlight them -> click means they are being defined
    #   when over (corner of) region, do nothin (can't select region) - XXX could use this to delete region
    # - MODE_PLAYER_SELECTED: drawing lines is on
    #   when over another player, show options: blocking strategies if defender, passing options if qb
    #   double-click ends definition
    # - MODE_REGION_DEFINITION: clicked to start defining a region
    #   next click means region is defined, go back to MODE_NO_PLAYER_SELECTED
    # 
    def UpdateMousePlus(self, event):
        self.mouseX = event.x
        self.mouseY = event.y

        # updating mouse -- 
        if self.mode == 'MODE_NO_PLAYER_SELECTED':
            # check if we are over a player, and if so, highlight them and track
            self.hilite = 'HILITE_NOT_IN_ANYTHING'
            for p in self.gamePtr.activePlayers:
                dx = p.GetX() - self.mouseX
                dy = p.GetY() - self.mouseY
                d  = math.sqrt(dx*dx + dy*dy)
                # inside player AND he's on your team!
                if d < p.GetSize() and p.GetTeam() == 0:
                    p.Hilite()
                    self.hilite       = 'HILITE_IN_PLAYER'
                    self.hilitePlayer = p
                else:
                    p.Unhilite()

            # now check for a region: so we can delete it
            if self.gamePtr.offenseTeam == 0:
                boxList = self.playbookPtr.GetOffensiveBoxes()
            else:
                boxList = self.playbookPtr.GetDefensiveBoxes()

            if self.hilite == 'HILITE_NOT_IN_ANYTHING':
                for box in boxList:
                    if box.InUpperRightOfBox(self.mouseX, self.mouseY):
                        self.hilite = 'HILITE_IN_REGION'
                        SafeDelete(self.canvas, self.messageID)
                        coords = box.GetCoordsInPixels()
                        tx = (coords[0] + coords[2])/2.0
                        ty = Min(coords[1], coords[3]) - 15.0
                        self.messageID = self.canvas.create_text(tx, ty, text='Delete Box?', fill='orange', font=('courier', 20))
                        self.boxPtr = box
                        # print 'DELETING A BOX?', self.boxPtr
                        box.Hilite()
                    else:
                        box.Unhilite()

            if self.hilite == 'HILITE_NOT_IN_ANYTHING':
                SafeDelete(self.canvas, self.messageID)
            

        # updating mouse -- 
        elif self.mode == 'MODE_REGION_DEFINITION':
            # we are defining a region right now --> all we can do is keep drawing a box until the click to define the region
            SafeDelete(self.canvas, self.boxID)
            self.boxID = self.canvas.create_rectangle(self.mouseX, self.mouseY, self.boxX, self.boxY, outline='lightblue')
            return

        # updating mouse -- 
        elif self.mode == 'MODE_PLAYER_SELECTED':
            # a player has been selected, which means we are filling out their behavior
            # keep drawing lines, and do so until the double-click or other obvious end to the definition (pass to somebody, etc.)
            SafeDelete(self.canvas, self.lineID)
            self.lineID = self.canvas.create_line(self.anchorPoint[0], self.anchorPoint[1], self.mouseX, self.mouseY, fill='orange', width=2)

            # here, we could be looking for players to BLOCK
            self.hilite = 'HILITE_NOT_IN_ANYTHING'
            for p in self.gamePtr.activePlayers:
                dx = p.GetX() - self.mouseX
                dy = p.GetY() - self.mouseY
                d  = math.sqrt(dx*dx + dy*dy)
                s  = p.GetSize()
                if d < s and p != self.sourcePlayer:
                    p.Hilite()

                    if self.gamePtr.offenseTeam == 0:
                        if self.sourcePlayer.GetPosition() == 'QB' and p.GetTeam() == 0 and (p.GetPosition() == 'FB' or p.GetPosition() == 'TB'):
                            if dx < 0: # mouse is right of player
                                message = 'ThrowLeading'
                            else:
                                message = 'ThrowExact'
                        else:
                            # have to make sure this is the other team we are blocking...
                            if p.GetTeam() == 1:
                                if dy > s/3.0:
                                    message = 'BlockLeft'
                                elif dy < -s/3.0:
                                    message = 'BlockRight'
                                else:
                                    if dx < -s/3.0:
                                        message = 'Block'
                                    elif dx > s/3.0:
                                        message = 'PassBlock'
                                    else:
                                        message = 'BlockNearest'
                            else:
                                message = '?'
                    else:
                        # actions for a defender: to cover somebody
                        if p.GetTeam() == 1:
                            if dx > s/3.0 or dx < -s/3.0:
                                message = 'Cover'
                            else:
                                if dy > 0:
                                    message = 'CoverOut'
                                else:
                                    message = 'CoverIn'
                        else:
                            message = '?'

                    # the 'message' is used to show what you can do to that hilited player
                    SafeDelete(self.canvas, self.messageID)
                    if message != '?':
                        self.hilite        = 'HILITE_IN_PLAYER'
                        self.hilitePlayer  = p
                        self.hiliteAction  = message
                        self.messageID     = self.canvas.create_text(p.GetX(), p.GetY() - 20, text=message, fill='orange', font=('courier', 20))
                else:
                    # restore colors once not highlighted...
                    p.Unhilite()
            # 
            # NOTE: still in update mouse, under "MODE_PLAYER_SELECTED"
            # 
            # now check for ball (if we are on defense), as players can chase the ball
            # 
            if self.gamePtr.offenseTeam == 1:
                dx = self.gamePtr.ballPtr.GetX() - self.mouseX
                dy = self.gamePtr.ballPtr.GetY() - self.mouseY
                d  = math.sqrt(dx*dx + dy*dy)
                s  = 5
                if d < 5:
                    self.ballPtr.Hilite()
                    if dx > 1.5:
                        message = 'Chase'
                    elif dx < -1.5:
                        message = 'Lateral'
                    else:
                        message = 'Contain'

                    SafeDelete(self.canvas, self.messageID)
                    self.hilite       = 'HILITE_IN_BALL'
                    self.hiliteAction = message
                    self.messageID    = self.canvas.create_text(p.GetX(), p.GetY() - 20, text=message, fill='orange', font=('courier', 20))
                else:
                    # otherwise restore ball to its normal look
                    self.ballPtr.Unhilite()

            # 
            # NOTE: still in update mouse, under "MODE_PLAYER_SELECTED"
            # 
            if self.hilite == 'HILITE_NOT_IN_ANYTHING':
                # if nobody is highlighted, check if we are in a region, and highlight it
                if self.gamePtr.offenseTeam == 0:
                    boxList = self.playbookPtr.GetOffensiveBoxes()
                    message = 'If Box is Empty...'
                else:
                    boxList = self.playbookPtr.GetDefensiveBoxes()
                    message = 'Cover Zone'

                for box in boxList:
                    if box.InUpperLeftOfBox(self.mouseX, self.mouseY):
                        self.hilite = 'HILITE_IN_REGION'
                        self.boxPtr = box
                        box.Hilite()
                        # now put up a message
                        coords = box.GetCoordsInPixels()
                        tx = (coords[0] + coords[2])/2.0
                        ty = Min(coords[1], coords[3]) - 15.0
                        SafeDelete(self.canvas, self.messageID)
                        self.messageID = self.canvas.create_text(tx, ty, text=message, fill='orange', font=('courier', 20))
                    else:
                        box.Unhilite()
                
            # if nobody is highlighted, delete any message that might be outstanding
            if self.hilite == 'HILITE_NOT_IN_ANYTHING':
                SafeDelete(self.canvas, self.messageID)

    # Controller:
    def RecordPlayFinal(self):
        # record player behavior
        self.sourcePlayer.UpdateBehavior(self.behaviorList)
        #for b in self.behaviorList:
        #    print 'BEHAVIOR:', b

        # update playbook as well
        if self.gamePtr.offenseTeam == 0:
            self.gamePtr.playbookPtr[0].UpdateOffensivePlay(self.sourcePlayer.GetPosition(), self.behaviorList, reverse=False)
            self.gamePtr.playbookPtr[1].UpdateOffensivePlay(self.sourcePlayer.GetPosition(), self.behaviorList, reverse=True)
        else:
            self.gamePtr.playbookPtr[0].UpdateDefensivePlay(self.sourcePlayer.GetPosition(), self.behaviorList, reverse=False)
            self.gamePtr.playbookPtr[1].UpdateDefensivePlay(self.sourcePlayer.GetPosition(), self.behaviorList, reverse=True)

        # redraw the play now
        self.sourcePlayer.UndrawPlay()
        self.sourcePlayer.DrawPlay()

        # and update the little play too
        self.gamePtr.UndrawLittlePlay()
        self.gamePtr.DrawLittlePlay()

        # and reset all state, to allow next player definition
        self.ResetAll()

    # Controller:
    def RecordPlay(self):
        # is this an else clause, or just where the endif should go?
        if len(self.ifStack) > 0:
            tmp = self.ifStack.pop()
            if tmp[0] == 'EndIf':
                self.behaviorList.append({'action':'EndIf', 'target':''})
                if len(self.ifStack) > 0:
                    tmp = self.ifStack.pop()
            if tmp[0] == 'Else':
                self.anchorPoint = tmp[1]
                self.anchorPoint[1] += 14
                tx = self.fieldPtr.ReverseScaleX(self.anchorPoint[0] - self.gamePtr.lineOfScrimmageInPixels)
                ty = self.fieldPtr.ReverseScaleY(self.anchorPoint[1] - self.gamePtr.middleOfFieldInPixels)
                self.behaviorList.append({'action':'Else', 'target':[tx,ty]})

        # if all done, record the play and be done
        if len(self.ifStack) == 0:
            self.RecordPlayFinal()
            
    # Controller:
    def DoubleClick(self, event):
        if self.gamePtr.IsPractice() == False:
            return
        if self.mode == 'MODE_PLAYER_SELECTED':
            self.RecordPlay()

    # Controller:
    def ThrowOrPuntToPosition(self, punt):
        # player has to be QB (as this is just to throw to a particular position on the field)
        # XXX -- this will have to change
        if self.sourcePlayer.GetPosition() != 'QB':
            abort('NON QB TRYING TO THROW OR PUNT')

        tx = self.fieldPtr.ReverseScaleX(self.mouseX - self.gamePtr.lineOfScrimmageInPixels)
        ty = self.fieldPtr.ReverseScaleY(self.mouseY - self.gamePtr.middleOfFieldInPixels)

        # add throw position and block nearest behaviors
        if punt == True:
            self.behaviorList.append({'action':'Punt', 'target':[tx,ty]})
        else:
            self.behaviorList.append({'action':'ThrowPosition', 'target':[tx,ty]})
        self.lineIDList.append(self.canvas.create_line(self.anchorPoint[0], self.anchorPoint[1], self.mouseX, self.mouseY, fill='orange', width=2, arrow='last'))
        
    # Controller:
    def RightButtonPress(self, event):
        if self.playMode == True:
            self.gamePtr.RightButtonPress()
        else:
            if self.mode == 'MODE_PLAYER_SELECTED':
                self.ThrowOrPuntToPosition(punt=True)

    # Controller:
    def RightButtonRelease(self, event):
        if self.playMode == True:
            self.gamePtr.RightButtonRelease()

    # Controller:
    def ShiftLeftButtonPress(self, event):
        if self.playMode == False:
            if self.mode == 'MODE_PLAYER_SELECTED':
                self.ThrowOrPuntToPosition(punt=False)

    # Controller:
    def ShiftLeftButtonRelease(self, event):
        Nop()

    # Controller:
    def LeftButtonPress(self, event):
        if self.playMode == True:
            self.gamePtr.LeftButtonPress()
        else:
            if self.mode == 'MODE_REGION_DEFINITION':
                # end of drawing a box
                x1 = self.fieldPtr.ReverseScaleX(self.boxX - self.gamePtr.lineOfScrimmageInPixels)
                y1 = self.fieldPtr.ReverseScaleY(self.boxY - self.gamePtr.middleOfFieldInPixels)
                x2 = self.fieldPtr.ReverseScaleX(self.mouseX - self.gamePtr.lineOfScrimmageInPixels)
                y2 = self.fieldPtr.ReverseScaleY(self.mouseY - self.gamePtr.middleOfFieldInPixels)
                # print x1, y1, 'to', x2, y2

                # move out of box-drawing mode, delete box
                self.mode = 'NO_PLAYER_SELECTED'
                SafeDelete(self.canvas, self.boxID)

                # redraw play
                if self.gamePtr.offenseTeam == 0:
                    self.gamePtr.playbookPtr[0].AddOffensiveBox(x1, y1, x2, y2)
                    self.gamePtr.playbookPtr[0].UndrawOffensiveBoxes()
                    self.gamePtr.playbookPtr[0].DrawOffensiveBoxes()
                else:
                    self.gamePtr.playbookPtr[0].AddDefensiveBox(x1, y1, x2, y2)
                    self.gamePtr.playbookPtr[0].UndrawDefensiveBoxes()
                    self.gamePtr.playbookPtr[0].DrawDefensiveBoxes()

                self.ResetAll()

            # REMEMBER: LEFT BUTTON HAS BEEN PRESSED
            elif self.mode == 'MODE_NO_PLAYER_SELECTED':

                if self.hilite == 'HILITE_NOT_IN_ANYTHING':
                    self.mode = 'MODE_REGION_DEFINITION'
                    self.boxX = self.mouseX
                    self.boxY = self.mouseY
   
                elif self.hilite == 'HILITE_IN_PLAYER':
                    self.mode         = 'MODE_PLAYER_SELECTED'
                    self.sourcePlayer = self.hilitePlayer
                    self.anchorPoint  = [self.sourcePlayer.GetX(), self.sourcePlayer.GetY()]
                    self.lineIDList   = []
                    self.behaviorList = []
                    self.sourcePlayer.UndrawPlay()

                elif self.hilite == 'HILITE_IN_REGION':
                    # here is where we can present the delete option
                    # print 'DELETING A BOX', self.boxPtr
                    SafeDelete(self.canvas, self.messageID)
                    if self.gamePtr.offenseTeam == 0:
                        self.playbookPtr.DeleteOffensiveBox(self.boxPtr)
                    else:
                        self.playbookPtr.DeleteDefensiveBox(self.boxPtr)
                    self.ResetAll()
                    
            # REMEMBER: LEFT BUTTON HAS BEEN PRESSED
            elif self.mode == 'MODE_PLAYER_SELECTED':
                if self.hilite == 'HILITE_IN_PLAYER' or self.hilite == 'HILITE_IN_BALL':
                    doRecord = True
                    if self.hiliteAction != 'Chase' and self.hiliteAction != 'Lateral' and self.hiliteAction != 'Contain':
                        playerPosition = self.hilitePlayer.GetPosition()
                        if self.gamePtr.offenseTeam == 0:
                            if self.sourcePlayer.GetPosition() == 'QB':
                                self.behaviorList.append({'action':self.hiliteAction, 'target':playerPosition})
                                # self.anchorPoint = [self.mouseX, self.mouseY]
                                if self.hiliteAction == 'ThrowLeading' or self.hiliteAction == 'ThrowExact':
                                    self.lineIDList.append(self.canvas.create_line(self.anchorPoint[0], self.anchorPoint[1], self.mouseX, self.mouseY,
                                                                                   fill='orange', width=2, arrow='last'))
                                    doRecord = False
                                # self.behaviorList.append({'action':'BlockNearest', 'target':''})
                            else:
                                self.behaviorList.append({'action':self.hiliteAction, 'target':playerPosition})
                        else:
                            self.behaviorList.append({'action':self.hiliteAction, 'target':playerPosition})
                    else:
                        # chase or lateral or contain (this means we're doing something to the ball, not a player)
                        self.behaviorList.append({'action':self.hiliteAction, 'target':'ball'})
                        self.ballPtr.Unhilite()

                    # record play at this point
                    if doRecord == True:
                        self.RecordPlay()

                elif self.hilite == 'HILITE_IN_REGION':
                    # this could be in a region ...
                    box = self.boxPtr.GetCoords()
                    SafeDelete(self.canvas, self.messageID)

                    if self.gamePtr.offenseTeam == 0:
                        # must now add 'if statement' to the code, and be ready for the 'else' clause
                        ax = self.anchorPoint[0]
                        ay = self.anchorPoint[1]
                        self.behaviorList.append({'action':'IfRegionEmpty', 'target':[box[0], box[1], box[2], box[3]]})
                        self.lineIDList.append(self.canvas.create_rectangle(ax-10,ay-10,ax+10,ay+10, fill='lightblue', outline='white'))
                        # print self.behaviorList
                        # now move on to define the IF clause (after that, the ELSE clause)
                        self.anchorPoint[0] += 10
                        self.anchorPoint[1] -= 7
                        self.ifStack.append(['EndIf', self.anchorPoint])
                        self.ifStack.append(['Else', self.anchorPoint])
                    else:
                        self.behaviorList.append({'action':'ZoneRegion', 'target':[box[0], box[1], box[2], box[3]]})
                        self.RecordPlay()
                        
                elif self.hilite == 'HILITE_NOT_IN_ANYTHING':
                    # not in a player or region, hence just part of a move
                    self.lineIDList.append(self.canvas.create_line(self.anchorPoint[0], self.anchorPoint[1], self.mouseX, self.mouseY, fill='orange', width=2))
                    tx = self.fieldPtr.ReverseScaleX(self.mouseX - self.anchorPoint[0])
                    ty = self.fieldPtr.ReverseScaleY(self.mouseY - self.anchorPoint[1])
                    if self.mouseX < self.fieldPtr.rightTD or self.gamePtr.offenseTeam == 1:
                        self.behaviorList.append({'action':'MoveTo', 'target':[tx,ty], 'mode':'relative'})
                    else:
                        self.behaviorList.append({'action':'MoveAndJuke', 'target':[tx,ty]})
                    self.anchorPoint = [self.mouseX, self.mouseY]

                else:
                    Abort('bad hilite mode: ' + self.hilite)

    # Controller:
    def LeftButtonRelease(self, event):
        if self.playMode == True:
            self.gamePtr.LeftButtonRelease()

    # Controller:
    def TogglePlayDefineMode(self, event):
        if self.gamePtr.IsPractice() == True:
            if self.playMode == True:
                self.SetModeToDefining()
            else:
                self.SetModeToPlaying()

    # Controller:
    def ToggleOffenseDefense(self, event):
        if self.gamePtr.IsPractice() == True:
            if self.playMode == True:
                self.gamePtr.ToggleOffenseDefense()

    # Controller:
    def FlipPlay(self, event):
        if self.gamePtr.IsPractice() == True:
            if self.playMode == True:
                self.gamePtr.FlipPlay()

    # Controller:
    def PlaybookUp(self, event):
        self.gamePtr.IncreaseLittlePlay()
        
    # Controller:
    def PlaybookDown(self, event):
        self.gamePtr.DecreaseLittlePlay()

    # Controller:
    def SelectPlay(self, event):
        self.gamePtr.SelectLittlePlay()

    # Controller:
    def FormationUp(self, event):
        if self.gamePtr.IsPractice() == True:
            if self.playMode == True:
                self.gamePtr.PracticeFormationUp()
        
    # Controller:
    def FormationDown(self, event):
        if self.gamePtr.IsPractice() == True:
            if self.playMode == True:
                self.gamePtr.PracticeFormationDown()

    # Controller:
    def OtherPlaybookUp(self, event):
        if self.gamePtr.IsPractice() == True:
            if self.playMode == True:
                self.gamePtr.PracticePlaybookUp()
        
    # Controller:
    def OtherPlaybookDown(self, event):
        if self.gamePtr.IsPractice() == True:
            if self.playMode == True:
                self.gamePtr.PracticePlaybookDown()

    # Controller:
    def CopyPlay(self, event):
        if self.gamePtr.IsPractice() == True:
            if self.playMode == True:
                self.gamePtr.CopyPlay()

    # Controller:
    def PastePlay(self, event):
        if self.gamePtr.IsPractice() == True:
            if self.playMode == True:
                self.gamePtr.PastePlay()

    # Controller:
    def Hike(self, event):
        if self.playMode == True:
            self.gamePtr.Hike()
        else:
            self.scoreboardPtr.Flash('Cannot Hike: You are in Play Definition Mode', 5000)
        
    # Controller:
    def Exit(self, event):
        self.gamePtr.playbookPtr[0].SaveOffense()
        self.gamePtr.playbookPtr[0].SaveDefense()
        exit(0)

    # Controller:
    def Pause(self, event):
        self.gamePtr.Pause()

    # Controller:
    def Replay(self, event):
        self.gamePtr.Replay()

    # Controller:
    def Number1(self, event):
        self.gamePtr.NumberPress(1)

    # Controller:
    def Number2(self, event):
        self.gamePtr.NumberPress(2)

    # Controller:
    def Number3(self, event):
        self.gamePtr.NumberPress(3)

    # Controller:
    def Number4(self, event):
        self.gamePtr.NumberPress(4)

    # Controller:
    def Number5(self, event):
        self.gamePtr.NumberPress(5)

    # Controller:
    def Number6(self, event):
        self.gamePtr.NumberPress(6)

#
# class Scoreboard
# 
# general class for all info below the field
# 
class Scoreboard:
    def __init__(self, root, canvas, fieldPtr, controller):
        self.root       = root
        self.canvas     = canvas
        self.fieldPtr   = fieldPtr
        self.controller = controller

        w = self.fieldPtr.GetWidth() + 0
        h = self.fieldPtr.GetHeight()

        self.fieldWidth  = float(w)
        self.fieldHeight = float(h)

        # sb -> scoreboard
        self.sbWidth  = 300.0
        self.sbHeight = 120.0
        self.sbX      = (w / 2.0) + 5.0 + (self.sbWidth / 2.0) + 250.0
        self.sbY      = h + 30.0
        self.sbLeft   = self.sbX - (self.sbWidth/2.0)
        self.sbRight  = self.sbX + (self.sbWidth/2.0)
        self.sbTop    = self.sbY
        self.sbBottom = self.sbY + self.sbHeight
        self.sbID     = self.canvas.create_rectangle(self.sbLeft, self.sbTop, self.sbRight, self.sbBottom, fill='black', outline='black')

        # log -> log of what has happened
        self.logWidth  = 300.0
        self.logX      = self.sbLeft - self.logWidth - 5.0 
        self.logY      = self.sbY
        self.logHeight = self.sbHeight
        self.logID     = self.canvas.create_rectangle(self.logX, self.logY, self.logX + self.logWidth, self.logY + self.logHeight, fill='white', outline='black')

        # pst -> play selection thing
        self.pstWidth  = 150.0
        self.pstHeight = self.sbHeight
        self.pstX      = self.sbLeft - self.logWidth - self.pstWidth - 15.0
        self.pstY      = self.sbY
        self.pstLOS    = self.pstX + (self.pstWidth/2.0)
        self.pstMOF    = self.pstY + (self.pstHeight/2.0)
        self.pstID     = self.canvas.create_rectangle(self.pstX, self.pstY, self.pstX + self.pstWidth, self.pstY + self.pstHeight, fill='darkgreen', outline='darkgreen')
        self.pstLosID  = self.canvas.create_line(self.pstLOS, self.pstY, self.pstLOS, self.pstY + self.pstHeight, fill='yellow', dash=(1,1))
        self.pstScaleX = self.fieldWidth  / self.pstWidth
        self.pstScaleY = self.fieldHeight / self.pstHeight

        # other stuff

        self.font14 = ('Courier', 14)
        self.font12 = ('Courier', 12)
        self.font10 = ('Courier', 10)
        self.font8  = ('Courier', 8)

        self.textColor          = 'yellow'
        self.leftTeamNameID     = -1
        self.rightTeamNameID    = -1

        self.leftTeamScoreID    = -1
        self.rightTeamScoreID   = -1

        self.leftTeamScore      = 0
        self.rightTeamScore     = 0

        self.minutesLeft        = 0
        self.secondsLeft        = 0
        self.clockID            = -1

        self.playSecondsReset   = 10
        self.playSeconds        = self.playSecondsReset
        self.playClockID        = -1

        self.downID             = -1
        self.togoID             = -1

        self.half               = 1
        self.halfID             = -1

        self.leftBallID         = -1
        self.rightBallID        = -1

        self.leftPlayID         = -1
        self.leftFormationID    = -1
        self.rightPlayID        = -1
        self.rightFormationID   = -1

        self.leftYardID         = -1
        self.leftTimesRunID     = -1

        self.leftTotalPlays     = 0
        self.leftTotalYardsID   = -1
        self.leftRunYardsID     = -1
        self.leftPassYardsID    = -1

        self.rightTotalYardsID  = -1
        self.rightRunYardsID    = -1
        self.rightPassYardsID   = -1

        self.gamePtr            = -1

        self.littlePlayID1      = -1
        self.littlePlayID2      = -1

        # set initial values and draw them...
        self.UpdateLeftTeamScore(0)
        self.UpdateRightTeamScore(0)
        self.DrawClock()
        self.DrawPlayClock()
        self.UpdateDownDistance(1, 10)
        self.UpdateHalf(1)
        self.UpdateBallOwner(0)
        self.UpdateLeftPlay('0')
        self.UpdateLeftFormation('0')
        self.UpdateRightPlay('-')
        self.UpdateRightFormation('-')
        self.UpdateLeftYards(0.0)
        self.UpdateLeftTimesRun(0.0)
        self.UpdateLeftTotalYards(0.0, 0.0, 0.0)
        self.UpdateRightTotalYards(0.0, 0.0, 0.0)
        self.UpdateLittlePlay(0)

        # new controller info for newbie players
        self.controlsID = {}
        for i in range(10):
            self.controlsID[i] = -1

        # keep track of what is going on in the game, etc.
        self.playClockOn = False
        self.clockOn     = False
        self.halfOver    = False
        self.gameOver    = False
        self.whichHalf   = 1

        # log
        self.logText    = []
        self.logTextIDs = []

        # for pausing the game
        self.clockFreeze = False

        self.flashCount = 0

        # check every second...
        self.root.after(1000, self.ClockUpdate)

    # Scoreboard:
    def SetGamePtr(self, gamePtr):
        self.gamePtr = gamePtr

    # Scoreboard:
    def UpdateLittlePlay(self, value):
        if self.gamePtr != -1:
            if self.gamePtr.offenseTeam == 0:
                (y, p, i) = self.gamePtr.GetOffYardsPlaysInts(0, value)
            else:
                (y, p, i) = self.gamePtr.GetDefYardsPlaysInts(0, value)
        else:
            (y, p, i) = (0, 0, 0)
        (avg, iavg) = ('-', '-')
        if p > 0:
            avg = '%.1f' % (y/p)
        if i > 0:
            iavg = '%.1f' % (i/p)

        SafeDelete(self.canvas, self.littlePlayID1)
        SafeDelete(self.canvas, self.littlePlayID2)
        
        self.littlePlayID1 = self.canvas.create_text(self.pstX+5, self.pstY+5, text='Play:' + str(value), fill=self.textColor, font=self.font14, anchor='w')
        self.littlePlayID2 = self.canvas.create_text(self.pstX+5, self.pstY+self.pstHeight-5, text='[%d y:%s i:%s]' % (int(p), avg, iavg), fill=self.textColor, font=self.font14, anchor='w')

    # Scoreboard:
    def SetLeftTeam(self, leftTeam):
        SafeDelete(self.canvas, self.leftTeamNameID)
        self.leftTeamNameID = self.canvas.create_text(self.sbLeft+40, self.sbTop+5, text=leftTeam, fill=self.textColor, font=self.font14, anchor='n')

    # Scoreboard:
    def SetRightTeam(self, rightTeam):
        SafeDelete(self.canvas, self.rightTeamNameID)
        self.rightTeamNameID = self.canvas.create_text(self.sbRight-40, self.sbTop+5, text=rightTeam, fill=self.textColor, font=self.font14, anchor='n')

    # Scoreboard:
    def GetPlayClock(self):
        return self.playSeconds

    # Scoreboard:
    def GetClockInSeconds(self):
        return (60 * self.minutesLeft) + self.secondsLeft

    # Scoreboard:
    def GetLeftScore(self):
        return self.leftTeamScore

    # Scoreboard:
    def GetRightScore(self):
        return self.rightTeamScore

    # Scoreboard:
    def FlashDone(self, elementID):
        self.canvas.delete(elementID)
        self.flashCount = self.flashCount - 1

    # Scoreboard:
    def Flash(self, text, howLong, size=40):
        elementID = self.canvas.create_text(self.fieldWidth/2.0, (self.fieldHeight/4.0) + (40*self.flashCount), text=text, font=('Courier', size), fill='orange')
        self.flashCount = self.flashCount + 1
        self.root.after(howLong, self.FlashDone, elementID)

    # Scoreboard:
    def LogText(self, text):
        # delete old IDs
        self.logText.append(text)
        for textID in self.logTextIDs:
            self.canvas.delete(textID)
        self.logTextIDs = []
        # draw last 10 ones...
        lastEntry = len(self.logText)
        minEntry  = lastEntry - 8
        if minEntry < 0:
            minEntry = 0
        y    = self.logY + 8
        for i in range(minEntry, lastEntry):
            newID = self.canvas.create_text(self.logX + 10, y, font=('courier', 12), text=self.logText[i], anchor='w')
            self.logTextIDs.append(newID)
            y = y + 15

    # Scoreboard:
    def SetGamePtr(self, gamePtr):
        self.gamePtr = gamePtr
        self.UpdateControls()

    # Scoreboard:
    def StartPlayClock(self):
        self.playClockOn = True

    # Scoreboard:
    def StartClock(self):
        self.clockOn = True

    # Scoreboard:
    def StopPlayClock(self):
        self.playClockOn = False

    # Scoreboard:
    def StopClock(self):
        self.clockOn = False

    # Scoreboard:
    def ResetPlayClock(self):
        self.playSeconds = self.playSecondsReset
        self.DrawPlayClock()

    # Scoreboard:
    def UpdateLeftYards(self, yards):
        SafeDelete(self.canvas, self.leftYardID)
        (x, y) = (10, self.fieldHeight + 60)
        self.leftYardID = self.canvas.create_text(x, y,      text='Avg Yards: %s' % str(yards), fill='black', font=self.font12, anchor='w')

    # Scoreboard:
    def UpdateLeftTimesRun(self, num):
        SafeDelete(self.canvas, self.leftTimesRunID)
        (x, y) = (10, self.fieldHeight + 75)
        self.leftTimesRunID = self.canvas.create_text(x, y,  text='Times run: %s' % str(num), fill='black', font=self.font12, anchor='w')

    # Scoreboard:
    def GetMode(self):
        if self.controller.playMode == True:
            return 'Not Defining; Can Hike'
        else:
            return 'Defining; Can\'t Hike'

    # Scoreboard:
    def GetOffOrDef(self):
        if self.gamePtr.offenseTeam == 0:
            return 'On offense'
        else:
            return 'On defense'

    # Scoreboard:
    def UpdateControls(self):
        for i in range(10):
            SafeDelete(self.canvas, self.controlsID[i])
        
        (x, y) = (130, self.fieldHeight + 25)
        c = 0
        if self.gamePtr.IsPractice() == False:
            self.controlsID[c] = self.canvas.create_text(x, y, text='Hike                LeftMouse or h',                fill='black', font=self.font12, anchor='w')
            (c, y) = (c + 1, y + 15)
            self.controlsID[c] = self.canvas.create_text(x, y, text='Choose Play         Up:a  Down:z  Choose:<space>',  fill='black', font=self.font12, anchor='w')
            (c, y) = (c + 1, y + 15)
            self.controlsID[c] = self.canvas.create_text(x, y, text='Throw/Punt          Left/RightMouse on target',     fill='black', font=self.font12, anchor='w')
            (c, y) = (c + 1, y + 15)
            self.controlsID[c] = self.canvas.create_text(x, y, text='Pause               p',                             fill='black', font=self.font12, anchor='w')
            (c, y) = (c + 1, y + 15)
            self.controlsID[c] = self.canvas.create_text(x, y, text='Quit                Q',                             fill='black', font=self.font12, anchor='w')
        else:
            self.controlsID[c] = self.canvas.create_text(x, y, text='Hike                LeftClick or h',                fill='black', font=self.font12, anchor='w')
            (c, y) = (c + 1, y + 15)
            self.controlsID[c] = self.canvas.create_text(x, y, text='Choose Play         Up:a  Down:z  Choose:<space>',  fill='black', font=self.font12, anchor='w')
            (c, y) = (c + 1, y + 15)
            self.controlsID[c] = self.canvas.create_text(x, y, text='Choose Formation    Up:s  Down:x',                  fill='black', font=self.font12, anchor='w')
            (c, y) = (c + 1, y + 15)
            self.controlsID[c] = self.canvas.create_text(x, y, text='Define Play?        d [%s]' % self.GetMode(),       fill='black', font=self.font12, anchor='w')
            (c, y) = (c + 1, y + 15)
            self.controlsID[c] = self.canvas.create_text(x, y, text='Toggle Off/Def      t [%s]' % self.GetOffOrDef(),   fill='black', font=self.font12, anchor='w')
            (c, y) = (c + 1, y + 15)
            self.controlsID[c] = self.canvas.create_text(x, y, text='Other Team\'s Play   Up:j  Down:m',                 fill='black', font=self.font12, anchor='w')
            (c, y) = (c + 1, y + 15)
            self.controlsID[c] = self.canvas.create_text(x, y, text='Copy Play           c',                             fill='black', font=self.font12, anchor='w')
            (c, y) = (c + 1, y + 15)
            self.controlsID[c] = self.canvas.create_text(x, y, text='Paste Play          v',                             fill='black', font=self.font12, anchor='w')
            (c, y) = (c + 1, y + 15)
            self.controlsID[c] = self.canvas.create_text(x, y, text='Throw/Punt          Left/RightMouse on target',     fill='black', font=self.font12, anchor='w')
            (c, y) = (c + 1, y + 15)
            self.controlsID[c] = self.canvas.create_text(x, y, text='Quit                Q',                             fill='black', font=self.font12, anchor='w')

    # Scoreboard:
    def UpdateLeftPlay(self, play):
        SafeDelete(self.canvas, self.leftPlayID)
        (x, y) = (10, self.fieldHeight + 25)
        self.leftPlayID = self.canvas.create_text(x, y,      text='Play     : %2s' % str(play), fill='black', font=self.font12, anchor='w')

    # Scoreboard:
    def UpdateLeftFormation(self, formation):
        SafeDelete(self.canvas, self.leftFormationID)
        (x, y) = (10, self.fieldHeight + 40)
        self.leftFormationID = self.canvas.create_text(x, y, text='Formation: %2s' % str(formation), fill='black', font=self.font12, anchor='w')

    # Scoreboard:
    def UpdateRightPlay(self, play):
        SafeDelete(self.canvas, self.rightPlayID)
        (x, y) = (self.fieldWidth - 10, self.fieldHeight + 25)
        self.rightPlayID = self.canvas.create_text(x, y,      text='Play     : %2s' % str(play), fill='black', font=self.font12, anchor='e')

    # Scoreboard:
    def UpdateRightFormation(self, formation):
        SafeDelete(self.canvas, self.rightFormationID)
        (x, y) = (self.fieldWidth - 10, self.fieldHeight + 40)
        self.rightFormationID = self.canvas.create_text(x, y, text='Formation: %2s' % str(formation), fill='black', font=self.font12, anchor='e')

    # Scoreboard: 
    def UpdateBallOwner(self, team):
        self.hasBall = team

        SafeDelete(self.canvas, self.leftBallID)
        SafeDelete(self.canvas, self.rightBallID)
        
        if self.hasBall == 0:
            self.leftBallID = self.canvas.create_oval(self.sbLeft  + 22, self.sbY + 28, self.sbLeft  + 26, self.sbY + 32, fill='orange', outline='orange')
            self.rightBallID = self.canvas.create_oval(self.sbRight - 22, self.sbY + 28, self.sbRight - 26, self.sbY + 32, fill='',       outline='orange')
        else:
            self.leftBallID = self.canvas.create_oval(self.sbLeft  + 22, self.sbY + 28, self.sbLeft  + 26, self.sbY + 32, fill='',       outline='orange')
            self.rightBallID = self.canvas.create_oval(self.sbRight - 22, self.sbY + 28, self.sbRight - 26, self.sbY + 32, fill='orange', outline='orange')

    # Scoreboard: 
    def UpdateHalf(self, half):
        self.half = half
        if self.half == 1:
            self.halfStr = '1st Half'
        else:
            self.halfStr = '2nd Half'
        SafeDelete(self.canvas, self.halfID)
        self.halfID = self.canvas.create_text(self.sbX, self.sbY+44, text=self.halfStr, font=self.font12, fill=self.textColor)

    # Scoreboard:
    def UpdateLeftTotalYards(self, totalYards, runYards, passYards):
        SafeDelete(self.canvas, self.leftTotalYardsID)
        SafeDelete(self.canvas, self.leftRunYardsID)
        SafeDelete(self.canvas, self.leftPassYardsID)
        self.leftRunYardsID   = self.canvas.create_text(self.sbLeft+5, self.sbY + 50, text='Run  : %3.1f' % runYards,   font=self.font10, fill=self.textColor, anchor='w')
        self.leftPassYardsID  = self.canvas.create_text(self.sbLeft+5, self.sbY + 60, text='Pass : %3.1f' % passYards,  font=self.font10, fill=self.textColor, anchor='w')
        self.leftTotalYardsID = self.canvas.create_text(self.sbLeft+5, self.sbY + 70, text='Total: %3.1f' % totalYards, font=self.font10, fill=self.textColor, anchor='w')

    # Scoreboard:
    def UpdateRightTotalYards(self, totalYards, runYards, passYards):
        SafeDelete(self.canvas, self.rightTotalYardsID)
        SafeDelete(self.canvas, self.rightRunYardsID)
        SafeDelete(self.canvas, self.rightPassYardsID)
        self.rightRunYardsID   = self.canvas.create_text(self.sbRight-5, self.sbY + 50, text='Run  : %3.1f' % runYards, font=self.font10, fill=self.textColor, anchor='e')
        self.rightPassYardsID  = self.canvas.create_text(self.sbRight-5, self.sbY + 60, text='Pass : %3.1f' % passYards, font=self.font10, fill=self.textColor, anchor='e')
        self.rightTotalYardsID = self.canvas.create_text(self.sbRight-5, self.sbY + 70, text='Total: %3.1f' % totalYards, font=self.font10, fill=self.textColor, anchor='e')

    # Scoreboard: 
    def UpdateDownDistance(self, down, distance):
        self.down = down
        self.togo = distance

        SafeDelete(self.canvas, self.downID)
        self.downID = self.canvas.create_text(self.sbLeft  + 40, self.sbY+110, text='Down: ' + str(self.down), font=self.font14, fill=self.textColor)
        SafeDelete(self.canvas, self.togoID)
        self.togoID = self.canvas.create_text(self.sbRight - 52, self.sbY+110, text='To Go: ' + '%.1f' % self.togo, font=self.font14, fill=self.textColor)

    # Scoreboard: 
    def UpdateLeftTeamScore(self, howMuch):
        self.leftTeamScore = self.leftTeamScore + howMuch
        SafeDelete(self.canvas, self.leftTeamScoreID)
        self.leftTeamScoreID = self.canvas.create_text(self.sbLeft+40, self.sbTop+22, text=str(self.leftTeamScore), fill=self.textColor, font=self.font14, anchor='n')
        
    # Scoreboard: 
    def UpdateRightTeamScore(self, howMuch):
        self.rightTeamScore = self.rightTeamScore + howMuch
        SafeDelete(self.canvas, self.rightTeamScoreID)
        self.rightTeamScoreID = self.canvas.create_text(self.sbRight-40, self.sbTop+22, text=str(self.rightTeamScore), fill=self.textColor, font=self.font14, anchor='n')
        
    # Scoreboard: 
    def DrawPlayClock(self):
        SafeDelete(self.canvas, self.playClockID)
        self.playSecondsStr = '%02d' % self.playSeconds
        self.playClockID = self.canvas.create_text(self.sbX, self.sbY+77, text='Play: ' + str(self.playSecondsStr), font=self.font10, fill=self.textColor)

    # Scoreboard: 
    def DrawClock(self):
        SafeDelete(self.canvas, self.clockID)
        self.minutesLeftStr = '%02d' % self.minutesLeft
        self.secondsLeftStr = '%02d' % self.secondsLeft
        self.clockID = self.canvas.create_text(self.sbX, self.sbY+60, text='Time: ' + str(self.minutesLeftStr) + ':' + str(self.secondsLeftStr), font=self.font14, fill=self.textColor)

    # Scoreboard: 
    def ResetClock(self, minutes, seconds):
        self.minutesLeft = minutes
        self.secondsLeft = seconds
        self.playSeconds = self.playSecondsReset
        self.DrawClock()

    # Scoreboard: 
    def ClockUpdate(self):
        if self.clockFreeze == True:
            self.root.after(100, self.ClockUpdate)
            return
        
        if self.clockOn == True:
            self.secondsLeft = self.secondsLeft - 1

            # check for end of timer
            if self.secondsLeft == 0 and self.minutesLeft == 0:
                self.DrawClock()
                if self.whichHalf == 1:
                    self.gamePtr.HalfOver()
                else:
                    self.gamePtr.GameOver()
                self.clockOn   = False
                self.whichHalf = self.whichHalf + 1

            if self.secondsLeft < 0:
                self.secondsLeft = 59
                self.minutesLeft = self.minutesLeft - 1

            # draw the clock
            if self.clockOn == True:
                self.DrawClock()

        if self.playClockOn == True:
            self.playSeconds = self.playSeconds - 1
            if self.playSeconds == 0:
                self.gamePtr.DelayOfGame()
                self.playClockOn = False
            self.DrawPlayClock()
            
        self.root.after(1000, self.ClockUpdate)

    # Scoreboard:
    def ClockFreeze(self):
        self.clockFreeze = True

    # Scoreboard:
    def ClockUnfreeze(self):
        self.clockFreeze = False

# end Scoreboard::

class Field:
    def __init__(self, canvas, width):
        self.canvas = canvas

        # width is probably 1400
        
        # XXX actual width of a football field: 53 1/3 yards
        height = width * (54.0 / 120.0)

        self.widthInPixels  = width
        self.heightInPixels = height

        self.pixelsPerYard  = width / 120.0

        w = self.widthInPixels
        h = self.heightInPixels

        self.canvas.create_rectangle(0, 0, w, h, fill='darkgreen')

        # yardlines
        for x in range(0,120,10):
            xc = self.widthInPixels - (x * self.pixelsPerYard)
            self.canvas.create_rectangle(xc-1.5, 0, xc+1.5, h, fill='white', outline='')

        # sidelines
        self.canvas.create_rectangle(0, 0, w, 20, fill='white', outline='')
        self.canvas.create_rectangle(0, h, w, h - 20, fill='white', outline='')

        # text on field
        for x in range(10,100,10):
            xc = ((x + 10) * self.pixelsPerYard) - 2
            yc = 50
            if x > 50:
                yardmarker = 100 - x
            else:
                yardmarker = x
            font = ('courier', 30)
            self.canvas.create_text(xc, yc, text=str(yardmarker), fill='white', font=font)
            self.canvas.create_text(xc, h-yc, text=str(yardmarker), fill='white', font=font)

        # colored endzones
        self.rightTD = 110.0 * self.pixelsPerYard
        self.leftTD  =  10.0 * self.pixelsPerYard

        # how wide is the sideline?
        self.widthOfSideline = 20.0

        # out-of-bounds markers
        self.bottomOut = h - self.widthOfSideline
        self.topOut    = self.widthOfSideline
        self.rightOut  = 120.0 * self.pixelsPerYard
        self.leftOut   = 0.0

        # yard markers (sidelines)
        factor1 = 0.35
        factor2 = 0.65
        for x in range(10,110,1):
            xc = w - (x * self.pixelsPerYard)
            if x % 5 == 0:
                extra = 20
            else:
                extra = 0
            self.canvas.create_rectangle(xc-1.5, 20,          xc+1.5, 30+extra,          fill='white', outline='')
            self.canvas.create_rectangle(xc-1.5, h-20,        xc+1.5, h-30-extra,        fill='white', outline='')
            self.canvas.create_rectangle(xc-1,   factor1 * h, xc+1,  (factor1 * h) + 20, fill='white', outline='')
            self.canvas.create_rectangle(xc-1,   factor2 * h, xc+1,  (factor2 * h) - 20, fill='white', outline='')

        # orange cone markers
        self.canvas.create_rectangle(width-(10*self.pixelsPerYard)-1.5,  20,   w-(10*self.pixelsPerYard)+1.5,  17,   fill='orange', outline='orange')
        self.canvas.create_rectangle(width-(10*self.pixelsPerYard)-1.5,  h-20, w-(10*self.pixelsPerYard)+1.5,  h-17, fill='orange', outline='orange') 
        self.canvas.create_rectangle(width-(110*self.pixelsPerYard)-1.5, 20,   w-(110*self.pixelsPerYard)+1.5, 17,   fill='orange', outline='orange')
        self.canvas.create_rectangle(width-(110*self.pixelsPerYard)-1.5, h-20, w-(110*self.pixelsPerYard)+1.5, h-17, fill='orange', outline='orange') 

    def GetWidth(self):
        return self.widthInPixels
    
    def GetHeight(self):
        return self.heightInPixels
    
    # from pixels to yards
    def ReverseScaleX(self, value):
        return value / self.pixelsPerYard

    # from pixels to yards
    def ReverseScaleY(self, value):
        return value / self.pixelsPerYard

    # from yards to pixels
    def ScaleX(self, value):
        return self.pixelsPerYard * value

    # from yards to pixels
    def ScaleY(self, value):
        return self.pixelsPerYard * value
        return rv

    # Field:
    def LimitX(self, value):
        if value < self.leftOut:
            return 5.0
        elif value > self.rightOut:
            return self.rightOut - 5.0
        return value

    # Field:
    def LimitY(self, value):
        if value < self.topOut:
            return self.topOut + 5.0
        elif value > self.bottomOut:
            return self.bottomOut - 5.0
        return value

    # Field:
    # from line of scrimmage and middle of field
    def TranslateX(self, value):
        LOS = self.gamePtr.GetLineOfScrimmage()
        return self.pixelsPerYard * (value + LOS + 10.0)
    
    # Field:
    def TranslateY(self, value):
        MOF = self.gamePtr.GetMiddleOfField()
        return self.pixelsPerYard * (value + MOF)
    
    # Field:
    def GetCanvas(self):
        return self.canvas
# END: class Field


class Ball:
    def __init__(self, fieldPtr, gamePtr, x, y, canvas):
        self.fieldPtr      = fieldPtr
        self.gamePtr       = gamePtr
        self.x             = (x + 10.0) * self.fieldPtr.pixelsPerYard
        self.y             = y * self.fieldPtr.pixelsPerYard
        self.canvas        = canvas
        self.shadowID      = self.canvas.create_oval(self.x-6, self.y-4, self.x+6, self.y+4, fill='black',  outline='black')
        self.id            = self.canvas.create_oval(self.x-6, self.y-4, self.x+6, self.y+4, fill='yellow', outline='yellow')
        self.counter       = 0
        self.shadowX       = 0
        self.shadowN       = 0
        self.trajectory    = 400.0
        self.adj           = 0.0

        # speed of the ball
        self.vx            = 0.0
        self.vy            = 0.0

        self.playerPtr     = ''
        self.state         = 'Ball-NotHeld'

        self.replayRecord  = False
        self.replayBuffer  = []

    # Ball:
    def StartRecording(self):
        self.replayRecord = True
        self.replayBuffer = []

    # Ball:
    def StopRecording(self):
        self.replayRecord = False

    # Ball: 
    def Hilite(self):
        self.canvas.itemconfig(self.id, outline='orange', width=2)

    # Ball: 
    def Unhilite(self):
        self.canvas.itemconfig(self.id, outline='yellow', width=1)

    # Ball: 
    def GetX(self):
        return self.x

    # Ball: 
    def GetY(self):
        return self.y

    # Ball: 
    def GetXVec(self):
        if self.state == 'Ball-Held':
            return self.playerPtr.GetXVec()
        else:
            return self.vx

    # Ball: 
    def GetYVec(self):
        if self.state == 'Ball-Held':
            return self.playerPtr.GetYVec()
        else:
            return self.vy

    # Ball:
    def Record(self, x, y):
        if self.replayRecord == True:
            self.replayBuffer.append((x, y - self.adj))

    # Ball: 
    def Move(self, x, y):
        # normal move (and possible record)
        self.x = x
        self.y = y
        self.Record(x, y)

    # Ball: 
    def MoveBack(self, x, y):
        # delete one from record buffer and then do move
        if self.replayRecord == True:
            del self.replayBuffer[len(self.replayBuffer) - 1]
        self.Move(x, y)

    # Ball: 
    def MoveInit(self, x, y):
        # move but don't record this
        self.x = x
        self.y = y

    # Ball: 
    def Redraw(self):
        # adjust shadow based on...
        self.adj = 0
        if self.state == 'Ball-Passed' or self.state == 'Ball-Punted':
            if self.shadowN > 0:
                self.adj = ((-self.trajectory / (self.shadowN * self.shadowN)) * (self.shadowX * self.shadowX)) + (self.trajectory * self.shadowX / self.shadowN)
        self.canvas.coords(self.shadowID, self.x-6, self.y-4, self.x+6, self.y+4)
        self.canvas.lift(self.shadowID)
        self.canvas.coords(self.id, self.x-6, self.y-4-self.adj, self.x+6, self.y+4-self.adj)
        self.canvas.lift(self.id)

    # Ball: 
    def DoesPlayerHaveBall(self):
        return self.state == 'Ball-Held'

    # Ball: 
    def PlayerWithBall(self):
        assert(self.state == 'Ball-Held')
        return self.playerPtr

    # Ball: 
    def HeldByPlayer(self, playerPtr):
        assert(self.state != 'Ball-Held')
        self.state     = 'Ball-Held'
        self.playerPtr = playerPtr

    # Ball: 
    def LostByPlayer(self, playerPtr):
        assert(self.state == 'Ball-Held')
        assert(self.playerPtr == playerPtr)
        self.state = 'Ball-NotHeld'

    # Ball: 
    def GetTarget(self):
        assert(self.state == 'Ball-Passed' or self.state == 'Ball-Punted')
        return [self.tx, self.ty]

    # Ball:
    def BeingPunted(self, player, tx, ty):
        assert(self.state == 'Ball-NotHeld')
        self.state = 'Ball-Punted'
        self.tx    = tx
        self.ty    = ty
        
        # make the target on the field
        self.targetSize = 10
        tsize = self.targetSize
        self.targetID = self.canvas.create_oval(self.tx - tsize, self.ty - tsize, self.tx + tsize, self.ty + tsize, fill='', outline='yellow')
        
        # calculate punt vectors
        dx = self.tx - self.playerPtr.GetX()
        dy = self.ty - self.playerPtr.GetY()
        dz = math.sqrt((dx*dx)+(dy*dy))
        if dz < 0.00001:
            dz = 1.0

        # set speed correctly (XXX)
        tspeed = 12
        self.vx = tspeed * (dx / dz)
        self.vy = tspeed * (dy / dz)

        # the counter is used to see when to rule the pass incomplete
        self.counter = int(dz / tspeed)
        self.shadowN = self.counter
        self.shadowX = 0


    # Ball: 
    def BeingPassed(self, player, tx, ty, reduceSpeed):
        # update state of ball
        assert(self.state == 'Ball-NotHeld')
        self.state = 'Ball-Passed'

        # and mark position
        self.tx = tx
        self.ty = ty

        # make the target on the field
        self.targetSize = 20
        tsize = self.targetSize
        self.targetID = self.canvas.create_oval(self.tx - tsize, self.ty - tsize, self.tx + tsize, self.ty + tsize, fill='', outline='yellow')

        # calculate pass vectors
        dx = self.tx - self.playerPtr.GetX()
        dy = self.ty - self.playerPtr.GetY()
        dz = math.sqrt((dx*dx)+(dy*dy))
        if dz < 0.00001:
            dz = 1.0

        # calc distance, adjust speed accordingly
        tspeed = player.GetThrowSpeed()
        if reduceSpeed == True:
            tspeed /= 1.33

        # set speed correctly
        self.vx = tspeed * (dx / dz)
        self.vy = tspeed * (dy / dz)

        # the counter is used to see when to rule the pass incomplete
        self.counter = int(dz / tspeed)
        self.shadowN = self.counter
        self.shadowX = 0
        # print 'INIT', self.counter, self.shadowN, self.shadowX

    # Ball: 
    def StepsLeftInThrow(self):
        return self.counter

    # Ball: 
    def WaitingForHike(self):
        self.state     = 'Ball-WaitingForHike'
        self.playerPtr = ''

    # Ball:
    def SetTrajectory(self, trajectory):
        # print 'TRAJECTORY', self.trajectory
        self.trajectory = trajectory

    # Ball: 
    def UpdateMovement(self):
        if self.state == 'Ball-Held':
            return True
        elif self.state == 'Ball-Passed' or self.state == 'Ball-Punted':
            self.Move(self.x + self.vx, self.y + self.vy)
            self.Redraw()

            # check for OOB
            if self.y < self.fieldPtr.topOut or self.y > self.fieldPtr.bottomOut or self.x < self.fieldPtr.leftOut or self.x > self.fieldPtr.rightOut:
                # ball is OOB
                self.canvas.delete(self.targetID)
                if self.state == 'Ball-Passed':
                    self.state     = 'Ball-WaitingForHike'
                    self.playerPtr = ''
                    return False
                else:
                    self.gamePtr.ballDownedAfterPunt = True
                    self.gamePtr.ChangePossession()
                    return True
            
            # check for catch, or for done with pass
            if self.counter < 3:
                # now check for a nearby player
                for p in self.gamePtr.activePlayers:
                    px = p.GetX() - self.x
                    py = p.GetY() - self.y
                    d = math.sqrt((px*px) + (py*py))
                    if (self.state == 'Ball-Passed' and d < self.targetSize and p.IsEligible()) or (self.state == 'Ball-Punted' and d < self.targetSize):
                        # caught or retrieved 
                        self.canvas.delete(self.targetID)
                        # print 'ACQUIRE BALL!'
                        p.AcquireBall()
                        p.gamePtr.DoCompletion(p)
                        return True
            if self.counter == 0:
                self.canvas.delete(self.targetID)
                if self.state == 'Ball-Passed':
                    # pass is now incomplete
                    self.state     = 'Ball-WaitingForHike'
                    self.playerPtr = ''
                    return False
                elif self.state == 'Ball-Punted':
                    # ball is now sitting there
                    self.vx = 0
                    self.vy = 0
                    return True
            self.counter -= 1
            self.shadowX += 1
            return True
        elif self.state == 'Ball-WaitingForHike':
            return True

#
# class Player
#
# used to move and draw each player
# also does some of the low level reaction to collisions,
# which is particularly important if you want the game to work
#
class Player:
    def __init__(self,
                 gamePtr,
                 fieldPtr,
                 canvas,
                 ballPtr,
                 controller,
                 team,
                 position,
                 x,
                 y,
                 mainColor,
                 outlineColor,
                 textColor='black',
                 size=12.0,
                 accel=1.0,
                 speed=4.0,
                 throwAccuracy=-1, 
                 throwDist=50,
                 throwSpeed=10,
                 mass=3,
                 behavior='',
                 ):
        self.fieldPtr      = fieldPtr
        self.canvas        = canvas
        self.gamePtr       = gamePtr
        self.ballPtr       = ballPtr
        self.controller    = controller
        self.position      = position
        self.team          = team
        self.x             = x
        self.y             = y
        self.speed         = speed
        self.maxSpeed      = speed
        self.maxAccel      = accel
        self.mass          = mass
        self.throwAccuracy = throwAccuracy
        self.throwDist     = throwDist
        self.throwSpeed    = throwSpeed
        self.mainColor     = mainColor
        self.outlineColor  = outlineColor
        self.textColor     = textColor
        self.size          = size
        self.behavior      = behavior
        self.inControl     = False

        # replay?
        self.replayBuffer  = []
        self.replayRecord  = False

        # team has to be 1 or 0, so ...
        self.otherTeam    = 1 - self.team

        if self.position in self.gamePtr.offensivePlayerPositions:
            self.onOffense = True
        else:
            self.onOffense = False

        # is this player an eligible receiver?
        if self.position == 'C' or self.position == 'LG' or self.position == 'RG' or self.position == 'QB':
            self.eligibleReceiver = False
        else:
            self.eligibleReceiver = True

        # initial movement vectors
        self.xVec = 0
        self.yVec = 0

        # id, distances
        self.followMouse  = False
        self.ID           = -1
        self.distances    = []
        # 100 is max number of players total, yes, this is ugly
        for i in range(0, 100):
            self.distances.append(-1)

        # initial draw, but why?
        self.font = ('Times', 12)
        self.id = self.canvas.create_oval(self.x-self.size, self.y-self.size, self.x+self.size, self.y+self.size,
                                          fill=self.mainColor, outline=self.outlineColor)
        # this will be filled in later...
        self.textID = self.canvas.create_text(self.x, self.y, text='', fill=self.textColor, font=self.font)
        
        # some other things
        self.lastX = x             # useful for moving back after a collision
        self.lastY = y

        self.xInit = x             # used to record the starting location on each play
        self.yInit = y

        # important: how many hits have you taken?
        self.hits       = 0
        
        self.repulseNum = -1        # avoid nearby teammates
        self.tempID     = -1        # for extra on-field drawing

        self.behavePtr  = 0                   # which behavior to be working on?
        self.behaveCnt  = len(self.behavior)  # how many total behaviors?

        # does not have the ball
        self.hasBall    = False

        # for drawing onto the field what the play is ...
        self.actionList = []

    # Player: IsEligible
    def IsEligible(self):
        return self.eligibleReceiver

    # Player: GetTeam
    def GetTeam(self):
        return self.team

    # Player: GetX
    def GetX(self):
        return self.x

    # Player: GetY
    def GetY(self):
        return self.y

    # Player:
    def GetSpeed(self):
        return self.maxSpeed

    # Player:
    def GetSize(self):
        return self.size

    # Player:
    def GetAccuracy(self):
        return self.throwAccuracy

    # Player: 
    def GetThrowSpeed(self):
        return self.throwSpeed

    # Player: 
    def GetThrowMax(self):
        return self.throwDist

    # Player:
    def GetPosition(self):
        return self.position

    # Player:
    def GetMass(self):
        return self.mass

    # Player: GetXVec
    def GetXVec(self):
        return self.xVec

    # Player: GetYVec
    def GetYVec(self):
        return self.yVec

    # Player: HasBall()
    def HasBall(self):
        return self.hasBall

    # Player: SetXVec
    def SetXVec(self, value):
        self.xVec = value

    # Player: 
    def SetYVec(self, value):
        self.yVec = value

    # Player: GetMainColor
    def GetMainColor(self):
        return self.mainColor

    # Player: SetID
    def SetID(self, newID):
        assert(self.ID == -1)
        self.ID = newID
        if self.team == 0:
            if self.onOffense == True:
                self.canvas.itemconfig(self.textID, text=str(self.ID+1)+':'+str(self.position))
            else:
                num = len(self.gamePtr.offensivePlayerPositions)
                self.canvas.itemconfig(self.textID, text=str(self.ID-num+1)+':'+str(self.position))
        else:
            # other team: just show their position names, not numbers
            self.canvas.itemconfig(self.textID, text=str(self.position))

    # Player: GetID
    def GetID(self):
        return self.ID

    # Player: SetDist
    def SetDist(self, otherPlayerPtr, distance):
        index = otherPlayerPtr.ID
        self.distances[index] = distance

    # Player: GetDist
    def GetDist(self, index):
        return self.distances[index]

    # Player: AcquireBall
    def AcquireBall(self):
        assert(self.hasBall == False)
        self.hasBall = True
        # print 'Player::AcquireBall()', self.position
        self.ballPtr.HeldByPlayer(self)

    # Player: LoseBall
    def LoseBall(self):
        assert(self.hasBall == True)
        self.hasBall = False
        # print 'Player::LoseBall()', self.position
        self.ballPtr.LostByPlayer(self)

    # Player:
    def RunToEndzone(self):
        # main effect of player running to end zone if not being actively controlled
        if self.team == 0:
            self.UpdateBehavior(behaviorList = [{ 'action':'MoveAndJuke', 'target':[self.fieldPtr.rightTD,self.y]}])
        else:
            self.UpdateBehavior(behaviorList = [{ 'action':'MoveAndJuke', 'target':[self.fieldPtr.leftTD,self.y]}])

    # Player: SlowDown
    def SlowDown(self):
        self.speed = 2.0

    # Player: SpeedUp
    def SpeedUp(self):
        self.speed = self.maxSpeed

    # Player:
    def Dist(self, player):
        xd = self.x - player.GetX()
        yd = self.y - player.GetY()
        return math.sqrt((xd*xd)+(yd*yd))

    # Player:
    def Avoid(self, other):
        self.repulse    = other
        self.repulseNum = other.ID

    # Player:
    def Ignore(self, other):
        self.repulseNum = -1

    # Player: MovePlayerToBallTarget
    # call this when you need to adjust the player's speed to the target
    def MovePlayerToBallTarget(self, tx, ty):
        counter = self.ballPtr.StepsLeftInThrow()
        dx = tx - self.x
        dy = ty - self.y
        distance = math.sqrt((dx*dx) + (dy*dy))
        if counter > 0:
            newSpeed = distance / counter
        else:
            newSpeed = self.maxSpeed
        if newSpeed > self.maxSpeed:
            newSpeed = self.maxSpeed

        self.UpdateBehavior(behaviorList = [{ 'action':'MoveTo', 'mode':'absolute', 'target':[tx,ty], 'speed':newSpeed}])

    def AdvanceOnePlay(self):
        if self.behaveIndex < len(self.behaveList) - 1:
            self.behaveIndex += 1

    def GetCurrentPlay(self):
        return self.behaveList[self.behaveIndex]

    def SkipUntil(self, str):
        # print 'SKIPPING UNTIL', str
        level = 0
        # print 'CURRENT ACTION', self.current['action']
        while self.current['action'] != str or level != 0:
            if self.current['action'] == 'IfRegionEmpty':
                level += 1
            elif self.current['action'] == 'EndIf':
                level -= 1
            self.current = self.GetCurrentPlay()
            # print '  skip: current = ', self.current['action']
            self.AdvanceOnePlay()
        # get that next play...
        self.current = self.GetCurrentPlay()
        # print 'SkipUntil: RESULT is', self.current['action'], self.current['target']

    # Player:
    def TranslateBoxToPixels(self, target, team):
        if team == 0:
            x1 = self.gamePtr.lineOfScrimmageInPixels + self.fieldPtr.ScaleX(float(target[0]))
            y1 = self.gamePtr.middleOfFieldInPixels   + self.fieldPtr.ScaleY(float(target[1]))
            x2 = self.gamePtr.lineOfScrimmageInPixels + self.fieldPtr.ScaleX(float(target[2]))
            y2 = self.gamePtr.middleOfFieldInPixels   + self.fieldPtr.ScaleY(float(target[3]))
        else:
            x1 = self.gamePtr.lineOfScrimmageInPixels - self.fieldPtr.ScaleX(float(target[0]))
            y1 = self.gamePtr.middleOfFieldInPixels   - self.fieldPtr.ScaleY(float(target[1]))
            x2 = self.gamePtr.lineOfScrimmageInPixels - self.fieldPtr.ScaleX(float(target[2]))
            y2 = self.gamePtr.middleOfFieldInPixels   - self.fieldPtr.ScaleY(float(target[3]))
        return (x1, y1, x2, y2)

    # Player:
    def GetNextBehavior(self):
        self.current = self.GetCurrentPlay()
        self.AdvanceOnePlay()

        action = self.current['action']
        target = self.current['target']

        if action == 'IfRegionEmpty':
            # check if region is empty
            (x1, y1, x2, y2) = self.TranslateBoxToPixels(target, self.team)

            # check if region is empty
            regionEmpty = True
            for position in ['CB', 'LB', 'S', 'LT', 'NT', 'RT']:
                p  = self.gamePtr.GetPlayerByPosition(self.gamePtr.defenseTeam, position)
                px = p.GetX()
                py = p.GetY()
                if ((px < x2 and px > x1) or (px < x1 and px > x2)) and ((py < y2 and py > y1) or (py < y1 and py > y2)):
                    regionEmpty = False
            
            # if it is, do these next things
            if regionEmpty == True:
                #print 'REGION  is EMPTY!'
                self.current = self.GetCurrentPlay()
            else:
                #print 'REGION NOT EMPTY!'
                self.current = self.GetCurrentPlay()
                self.SkipUntil('Else')
            self.AdvanceOnePlay()

        elif action == 'Else':
            # if we hit an else clause, it means we are at the end of an if block that was executed
            # this means we should just skip everything in this
            self.SkipUntil('EndIf')
            
        elif action == 'EndIf':
            # do we really need to do anything here?
            self.AdvanceOnePlay()
            self.current = self.GetCurrentPlay()

        # 
        # and from here, we process a real action... (not if/then/else)
        # 
        action = self.current['action']
        target = self.current['target']

        mode = 'relative'
        if 'mode' in self.current and self.current['mode'] == 'absolute':
            mode = 'absolute'
        elif 'mode' in self.current and self.current['mode'] == 'cover':
            mode = 'cover'
        elif 'mode' in self.current and self.current['mode'] == 'relative':
            mode = 'relative'
        elif 'mode' in self.current:
            assert(self.current['mode'] == 'SomethingBizarre')

        if 'speed' in self.current and self.current['speed'] != '':
            self.speed = self.current['speed']
        else:
            self.speed = self.maxSpeed

        # here is where the fun begins: what is the player gonna do?
        if action == 'Chase':
            self.target = self.ballPtr
        elif action == 'Lateral':
            self.target = self.ballPtr
        elif action == 'Contain':
            self.target = self.ballPtr
        elif action == 'Zone':
            # this is just the radius of the zone
            self.target = float(target)
            self.zoneX  = self.x
            self.zoneY  = self.y
        elif action == 'ZoneRegion':
            # the zone region is a box, specified by target
            (x1, y1, x2, y2) = self.TranslateBoxToPixels(target, self.team)
            self.target = [x1,y1,x2,y2]
        elif action == 'Cover' or action == 'CoverIn' or action == 'CoverOut':
            self.target = self.gamePtr.GetPlayerByPosition(self.otherTeam, target)
        elif action == 'PassBlock':
            self.target = self.gamePtr.GetPlayerByPosition(self.otherTeam, target)
        elif action == 'BlockNearest':
            # need to assign a player, now...
            # XXX this needs to change to just do the opposing team, whatever it is
            # XXX right now, assumes the offense is blocking the defense,
            # XXX but what about after an interception?
            minDist = 1e6
            for position in self.gamePtr.defensivePlayerPositions:
                t = self.gamePtr.GetPlayerByPosition(self.otherTeam, position)
                d = self.GetDist(t.ID)
                if d < minDist:
                    self.target = t
                    minDist = d
            assert(minDist < 1e6)
        elif action == 'Block':
            self.target = self.gamePtr.GetPlayerByPosition(self.otherTeam, target)
        elif action == 'BlockLeft':
            self.target = self.gamePtr.GetPlayerByPosition(self.otherTeam, target)
        elif action == 'BlockRight':
            self.target = self.gamePtr.GetPlayerByPosition(self.otherTeam, target)
        elif action == 'FollowMouse':
            self.target = ''
        elif action == 'Punt':
            self.target = [target[0], target[1]]
        elif action == 'ThrowPosition':
            self.target = [target[0], target[1]]
        elif action == 'ThrowLeading':
            self.target = self.gamePtr.GetPlayerByPosition(self.team, target)
        elif action == 'ThrowExact':
            self.target = self.gamePtr.GetPlayerByPosition(self.team, target)
        elif action == 'MoveAndJuke':
            self.target = [target[0], target[1]]
        elif action == 'MoveTo':
            if mode == 'relative':
                self.target = [self.x + self.fieldPtr.ScaleX(target[0]), self.y + self.fieldPtr.ScaleY(target[1])]
            else:
                self.target = [target[0], target[1]]

        elif action == 'MoveToExact':
            if mode == 'relative':
                self.target = [self.fieldPtr.ScaleX(target[0]) + self.gamePtr.GetLineOfScrimmageInPixels(),
                               self.fieldPtr.ScaleY(target[1]) + self.gamePtr.GetMiddleOfFieldInPixels()]
            elif mode == 'absolute':
                self.target = [target[0], target[1]]
            elif mode == 'cover':
                position = target[1]
                targetPlayer = self.gamePtr.GetPlayerByPosition(self.otherTeam, position)
                yTarget = targetPlayer.target[1]
                self.target = [self.fieldPtr.ScaleX(target[0]) + self.gamePtr.GetLineOfScrimmageInPixels(), yTarget]
        elif action == 'Wait':
            self.target = ''

        # update behavior (hopefully, target has been properly set)
        self.behavior = action

    # Player:
    def UpdateBehavior(self, behaviorList=''):
        self.behaveList  = behaviorList
        self.behaveIndex = 0
        self.behaveCnt   = len(behaviorList)

        # set up current behavior
        self.GetNextBehavior()
        
        # need to reset some things ...
        first  = behaviorList[0]
        action = first['action']
        if action == 'MoveToExact':
            self.followMouse = False

        self.repulseNum  = -1
        self.xInit       = self.x
        self.yInit       = self.y
        self.hits        = 0

        SafeDelete(self.canvas, self.tempID)
        self.tempID = -1

    # Player: DrawPlay
    # use this to draw a player's actions onto the screen ...
    # appends all item IDs to actionList (and thus use this to delete them from screen, later)
    def DrawPlay(self):
        color = 'orange'
        x = self.x
        y = self.y
        for behavior in self.behaveList:
            action = behavior['action']
            target = behavior['target']

            # this is just to make the message shorter ['Ch:b' instead of 'Chase:Ball']
            if target == 'ball':
                target = 'b'

            if action == 'Zone':
                d = float(target)
                self.actionList.append(self.canvas.create_oval(x-d, y-d, x+d, y+d, outline=color, dash=(2,2)))
            elif action == 'ZoneRegion':
                (x1, y1, x2, y2) = self.TranslateBoxToPixels(target, self.team)
                self.actionList.append(self.canvas.create_text(x, y+15, text='Zone', fill='red', font=('courier', 10)))
                self.actionList.append(self.canvas.create_line(x, y, (x1+x2)/2.0, (y1+y2)/2.0, fill='red', width=0.5, dash=(2,2)))
            elif action == 'Wait':
                Nop()
            elif action == 'IfRegionEmpty':
                # draw this thing AT the spot where the current position is
                self.actionList.append(self.canvas.create_rectangle(x-10,y-10,x+10,y+10, fill='lightblue', outline='white'))
                self.actionList.append(self.canvas.create_text(x+7, y-6, text='+', fill='black', font=('courier', 12)))
                self.actionList.append(self.canvas.create_text(x+7, y+6, text='-', fill='black', font=('courier', 12)))
            elif action == 'Else':
                # don't have to do much here, other than update the X,Y position for next actions...
                x = self.fieldPtr.ScaleX(target[0]) + self.gamePtr.lineOfScrimmageInPixels
                y = self.fieldPtr.ScaleY(target[1]) + self.gamePtr.middleOfFieldInPixels
            elif action == 'EndIf':
                Nop()
            elif action == 'MoveTo':
                if 'mode' in behavior and behavior['mode'] == 'absolute':
                    dx = target[0]
                    dy = target[1]
                else:
                    # relative mode means offset from where we are right now...
                    dx = x + self.fieldPtr.ScaleX(target[0])
                    dy = y + self.fieldPtr.ScaleY(target[1])
                self.actionList.append(self.canvas.create_line(x, y, dx, dy, fill=color, width=0.5, dash=(2,2)))
                x = dx
                y = dy
            elif action == 'MoveAndJuke':
                if self.team == 0:
                    dx = self.fieldPtr.rightTD + 5.0
                else:
                    dx = self.fieldPtr.leftTD  - 5.0
                dy = y
                self.actionList.append(self.canvas.create_line(x, y, dx, dy, fill=color, width=0.5, arrow='last'))
            elif action == 'BlockLeft' or action == 'BlockRight' or action == 'Block' or action == 'BlockNearest' or action == 'PassBlock':
                if action != 'BlockNearest':
                    t  = self.gamePtr.GetPlayerByPosition(self.otherTeam, target)
                    tx = t.GetX()
                    ty = t.GetY()
                    dx = tx - x
                    dy = ty - y
                    d  = math.sqrt((dx*dx)+(dy*dy))
                    if d != 0.0:
                        angle = math.asin(dy / d)
                    else:
                        angle = 0.0
                    ndx = math.cos(angle) * (d - self.size)
                    ndy = math.sin(angle) * (d - self.size)
                    if dx > 0:
                        ntx = x + ndx
                    else:
                        ntx = x - ndx
                    nty = y + ndy
                else:
                    # just for block nearest
                    angle = 0.0
                    if self.team == 0:
                        ntx = x + 20
                        dx  = 1.0
                    else:
                        ntx = x - 20
                        dx  = -1.0
                    nty = y

                if action != 'PassBlock':
                    self.actionList.append(self.canvas.create_line(x, y, ntx, nty, fill=color, width=3))
                else:
                    if dx > 0:
                        self.actionList.append(self.canvas.create_line(x, y, ntx, nty, fill=color, width=3, arrow='first'))
                    else:
                        self.actionList.append(self.canvas.create_line(x, y, ntx, nty, fill=color, width=3, arrow='last'))
                    

                if dx > 0:
                    if action == 'BlockLeft':
                        self.actionList.append(self.canvas.create_line(ntx, nty, ntx - (10*math.sin(angle)), nty + (10*math.cos(angle)), fill=color, width=2, arrow='last'))
                    else:
                        self.actionList.append(self.canvas.create_line(ntx, nty, ntx - (10*math.sin(angle)), nty + (10*math.cos(angle)), fill=color, width=2))
                    if action == 'BlockRight':
                        self.actionList.append(self.canvas.create_line(ntx, nty, ntx + (10*math.sin(angle)), nty - (10*math.cos(angle)), fill=color, width=2, arrow='last'))
                    else:
                        self.actionList.append(self.canvas.create_line(ntx, nty, ntx + (10*math.sin(angle)), nty - (10*math.cos(angle)), fill=color, width=2))
                else:
                    self.actionList.append(self.canvas.create_line(ntx, nty, ntx - (10*math.sin(angle)), nty - (10*math.cos(angle)), fill=color, width=2))
                    self.actionList.append(self.canvas.create_line(ntx, nty, ntx + (10*math.sin(angle)), nty + (10*math.cos(angle)), fill=color, width=2))
            elif action == 'Chase':
                self.actionList.append(self.canvas.create_text(x, y+15, text='Ch:' + target, fill='red', font=('courier', 10)))
            elif action == 'Cover':
                self.actionList.append(self.canvas.create_text(x, y+15, text='Cv:' + target, fill='red', font=('courier', 10)))
            elif action == 'CoverIn':
                self.actionList.append(self.canvas.create_text(x, y+15, text='CvI:' + target, fill='red', font=('courier', 10)))
            elif action == 'CoverOut':
                self.actionList.append(self.canvas.create_text(x, y+15, text='CvO:' + target, fill='red', font=('courier', 10)))
            elif action == 'Punt':
                # should draw some kind of ARC
                # print 'PUNT', target[0], target[1], self.gamePtr.offenseTeam, 'END'
                (dx, dy) = self.TranslateRelativeXY(self.gamePtr.offenseTeam, target[0], target[1])
                self.actionList.append(self.canvas.create_line(x, y, dx, dy, fill='orange', width=1.5, arrow='last'))
                self.actionList.append(self.canvas.create_text(x, y, text='Punt', fill='orange', font=('courier', 10)))
            elif action == 'ThrowPosition':
                # because position should be absolute!
                (dx, dy) = self.TranslateRelativeXY(self.gamePtr.offenseTeam, target[0], target[1])
                self.actionList.append(self.canvas.create_text(x, y, text='Position', fill='orange', font=('courier', 10)))
                self.actionList.append(self.canvas.create_line(x, y, dx, dy, fill='orange', width=1.5, arrow='last'))
            elif action == 'ThrowLeading' or action == 'ThrowExact':
                t  = self.gamePtr.GetPlayerByPosition(self.team, target)
                dx = t.GetX()
                dy = t.GetY()
                if action == 'ThrowLeading':
                    text = 'Lead'
                else:
                    text = 'Exact'
                self.actionList.append(self.canvas.create_text(x, y, text=text, fill='orange', font=('courier', 10)))
                self.actionList.append(self.canvas.create_line(x, y, dx, dy, fill='orange', width=1.5, arrow='last'))
            elif action == 'Lateral':
                self.actionList.append(self.canvas.create_text(x, y+15, text='L:' + target, fill='red', font=('courier', 10)))
            elif action == 'Contain':
                self.actionList.append(self.canvas.create_text(x, y+15, text='Ct:' + target, fill='red', font=('courier', 10)))
            else:
                Abort('unknown action in Player::DrawPlay() [%s]' % action)

    # Player: UndrawPlay
    def UndrawPlay(self):
        for item in self.actionList:
            self.canvas.delete(item)

    # Player: ReleaseControl
    def ReleaseControl(self):
        self.inControl = False
        self.canvas.itemconfig(self.id, outline=self.outlineColor, width=1)
        self.followMouse = False

    # Player: AcquireControl
    def AcquireControl(self):
        self.inControl = True
        self.canvas.itemconfig(self.id, outline='yellow', width=2)
        self.followMouse = True

    # Player: Hilite()
    def Hilite(self):
        self.canvas.itemconfig(self.id, outline='orange', width=2)

    # Player: Unhilite()
    def Unhilite(self):
        if self.inControl == True:
            self.canvas.itemconfig(self.id, outline='yellow', width=2)
        else:
            self.canvas.itemconfig(self.id, outline=self.outlineColor, width=1)

    def InControl(self):
        return self.inControl

    # Player: CalculateChaseTarget
    def CalculateChaseTarget(self, otherPtr):
        tx  = otherPtr.GetX()
        ty  = otherPtr.GetY()

        tvx = otherPtr.GetXVec()
        tvy = otherPtr.GetYVec()
        tv  = math.sqrt(tvx*tvx + tvy*tvy)

        distance = math.sqrt((self.x-tx)*(self.x-tx)+(self.y-ty)*(self.y-ty))

        if distance >= 500.0:
            factor = 500.0
        elif distance >= 300.0:
            factor = 300.0
        elif distance >= 200.0:
            factor = 200.0
        elif distance >= 100.0:
            factor = 100.0
        elif distance > 50.0:
            factor = 50.0
        else:
            factor = 10.0

        # need NORMALIZED vectors
        if tv < 0.001:
            tv = 1.0
        tmpX = (factor * tvx/tv)
        tmpY = (factor * tvy/tv)
        magnitude = math.sqrt(tmpX*tmpX + tmpY*tmpY)
        divideBy  = magnitude / factor
        if divideBy < 0.001:
            divideBy = 1.0
        tmpX = tmpX / divideBy
        tmpY = tmpY / divideBy

        xGoal = otherPtr.GetX() + tmpX
        yGoal = otherPtr.GetY() + tmpY
        return (xGoal, yGoal)

    # Player: 
    def TranslateRelativeXY(self, team, x, y):
        if team == 0:
            tx = self.fieldPtr.ScaleX(x) + self.gamePtr.lineOfScrimmageInPixels
            ty = self.fieldPtr.ScaleY(y) + self.gamePtr.middleOfFieldInPixels
        else:
            tx = self.gamePtr.lineOfScrimmageInPixels - self.fieldPtr.ScaleX(x)
            ty = self.gamePtr.middleOfFieldInPixels   - self.fieldPtr.ScaleY(y)
        return (tx, ty)

    # Player: 
    def CalculateMovement(self):
        if self.behavior == 'ThrowPosition':
            if self.hasBall == True:
                (tx, ty) = self.TranslateRelativeXY(self.gamePtr.offenseTeam, self.target[0], self.target[1])
                (tx, ty) = (self.fieldPtr.LimitX(tx), self.fieldPtr.LimitY(ty))
                self.gamePtr.PassBall(self, [tx, ty])
            self.GetNextBehavior()
            return
        elif self.behavior == 'Punt':
            if self.hasBall == True:
                (tx, ty) = self.TranslateRelativeXY(self.gamePtr.offenseTeam, self.target[0], self.target[1])
                self.gamePtr.PuntStart()
                self.gamePtr.PuntAccomplish(tx, ty)
            self.GetNextBehavior()
            return
        elif self.behavior == 'ThrowLeading' or self.behavior == 'ThrowExact':
            if self.hasBall == True and self.gamePtr.inControl != self.ID:
                tx = self.target.GetX()
                ty = self.target.GetY()
                if self.behavior == 'ThrowLeading':
                    # have to calculate where throw is heading...
                    dx = self.x - tx
                    dy = self.y - ty
                    distanceToPlayer = math.sqrt(dx*dx + dy*dy)
                    timeToGetThere   = distanceToPlayer / self.GetThrowSpeed()
                    playerWillMove   = self.target.GetSpeed() * timeToGetThere
                    vx = self.target.xVec
                    vy = self.target.yVec
                    tx = tx + (vx * timeToGetThere)
                    ty = ty + (vy * timeToGetThere)
                self.gamePtr.PassBall(self, [tx, ty])
                self.GetNextBehavior()
                self.xVec = 0
                self.yVec = 0
            return
        if self.followMouse == True or self.behavior == 'FollowMouse':
            xGoal = self.controller.GetMouseX()
            yGoal = self.controller.GetMouseY()
        elif self.behavior == 'Cover':
            (xGoal, yGoal) = (self.target.GetX(), self.target.GetY())
            if self.team == 0:
                xGoal = xGoal - (5 * self.fieldPtr.pixelsPerYard)
                if xGoal > self.gamePtr.lineOfScrimmageInPixels:
                    xGoal = self.gamePtr.lineOfScrimmageInPixels
            else:
                xGoal = xGoal + (5 * self.fieldPtr.pixelsPerYard)
                if xGoal < self.gamePtr.lineOfScrimmageInPixels:
                    xGoal = self.gamePtr.lineOfScrimmageInPixels
            if self.team == 0:
                if xGoal > self.xInit:
                    xGoal = self.xInit
            else:
                if xGoal < self.xInit:
                    xGoal = self.xInit
        elif self.behavior == 'CoverIn':
            (xGoal, yGoal) = self.CalculateChaseTarget(self.target)
            if self.target.GetY() > self.gamePtr.middleOfFieldInPixels:
                yGoal = yGoal - (5 * self.fieldPtr.pixelsPerYard)
            else:
                yGoal = yGoal + (5 * self.fieldPtr.pixelsPerYard)
            if self.team == 0:
                if xGoal > self.xInit:
                    xGoal = self.xInit
            else:
                if xGoal < self.xInit:
                    xGoal = self.xInit
        elif self.behavior == 'CoverOut':
            (xGoal, yGoal) = self.CalculateChaseTarget(self.target)
            if self.target.GetY() > self.gamePtr.middleOfFieldInPixels:
                yGoal = yGoal + (5 * self.fieldPtr.pixelsPerYard)
            else:
                yGoal = yGoal - (5 * self.fieldPtr.pixelsPerYard)
            if self.team == 0:
                if xGoal > self.xInit:
                    xGoal = self.xInit
            else:
                if xGoal < self.xInit:
                    xGoal = self.xInit
        elif self.behavior == 'ZoneRegion':
            (x1, y1, x2, y2) = (self.target[0], self.target[1], self.target[2], self.target[3])
            # first: root yourself to middle of zone
            (xGoal, yGoal) = ((x1 + x2) / 2.0, (y1 + y2) / 2.0)
            # adjust: do not go deep into endzone
            if self.team == 0:
                if xGoal < self.fieldPtr.leftTD:
                    xGoal = self.fieldPtr.leftTD
            else:
                if xGoal > self.fieldPtr.rightTD:
                    xGoal = self.fieldPtr.rightTD

            # look for players in zone
            avgList = []
            hasBall = False
            for position in ['QB', 'TB', 'FB']:
                otherPtr = self.gamePtr.GetPlayerByPosition(self.gamePtr.offenseTeam, position)
                (ox, oy) = self.CalculateChaseTarget(otherPtr)
                # check if player is in your zone...
                if Between(ox, x1, x2) and Between(oy, y1, y2):
                    # if they are AND they have the ball, this will be your only target
                    if otherPtr.HasBall():
                        hasBall  = True
                        (rx, ry) = (ox, oy)
                    # otherwise, you will see the "average" spot between them
                    avgList.append([ox,oy])

            if hasBall == True:
                # if somebody has ball in your zone, they are your target
                # (only useful for laterals and such, as chase is auto-behavior after a pass or crossing the line of scrimmage)
                (xGoal, yGoal) = (rx, ry)
            else:
                # OLD: else if anybody is in the zone, compute new goal based on their avg location
                # 
                #if len(avgList) > 0:
                #    (xSum, ySum, cnt) = (xGoal, yGoal, 1)
                #    for pair in avgList:
                #        xSum += pair[0]
                #        ySum += pair[1]
                #        cnt  += 1
                #    (xGoal, yGoal) = (xSum / cnt, ySum / cnt)
                # NEW
                if self.gamePtr.offenseTeam == 0:
                    furthestX = 0
                    dx        = 4 * self.fieldPtr.ScaleX(4)
                else:
                    furthestX = 100000
                    dx        = -4 * self.fieldPtr.ScaleX(4)
                if len(avgList) > 0:
                    for pair in avgList:
                        if self.gamePtr.offenseTeam == 0 and pair[0] > furthestX:
                            furthestX = pair[0]
                            (xGoal, yGoal) = (pair[0] + dx, pair[1])
                        elif self.gamePtr.offenseTeam == 1 and pair[0] < furthestX:
                            furthestX = pair[0]
                            (xGoal, yGoal) = (pair[0] + dx, pair[1])

        elif self.behavior == 'Zone':
            (xGoal, yGoal) = (self.zoneX, self.zoneY)
            (dxSum, dySum) = (0.0, 0.0)
            foundOne = False
            for position in ['QB', 'TB', 'FB']:
                otherPtr = self.gamePtr.GetPlayerByPosition(self.gamePtr.offenseTeam, position)
                (dx, dy) = (otherPtr.GetX() - self.zoneX, otherPtr.GetY() - self.zoneY)
                distance = math.sqrt((dx*dx)+(dy*dy))
                if distance < self.target:
                    (dxSum, dySum) = (dxSum + dx, dySum + dy)
                    foundOne = True
            # and now, with ball
            (bx, by) = (self.ballPtr.GetX(), self.ballPtr.GetY())
            bxSum = 0.0
            if foundOne == False:
                if self.team == 1:
                    bxSum = (+self.gamePtr.lineOfScrimmageInPixels - self.zoneX) / 3.0
                else:
                    bxSum = (-self.gamePtr.lineOfScrimmageInPixels + self.zoneX) / 3.0
            bySum = (by - self.zoneY) / 2.0
            (xGoal, yGoal) = (xGoal + dxSum + bxSum, yGoal + dySum + bySum)
                    
        elif self.behavior == 'Chase':
            (xGoal, yGoal) = self.CalculateChaseTarget(self.target)
        elif self.behavior == 'Lateral':
            (xGoal, yGoal) = self.CalculateChaseTarget(self.target)
            if self.team == 0:
                if xGoal > self.xInit:
                    xGoal = self.xInit
            else:
                if xGoal < self.xInit:
                    xGoal = self.xInit
        elif self.behavior == 'Contain':
            (xGoal, yGoal) = self.CalculateChaseTarget(self.target)

            tb = self.gamePtr.GetPlayerByPosition(self.gamePtr.offenseTeam, 'TB')
            fb = self.gamePtr.GetPlayerByPosition(self.gamePtr.offenseTeam, 'FB')

            (checkTB, checkFB) = (False, False)
            if self.team == 0:
                if tb.GetX() > self.gamePtr.lineOfScrimmageInPixels:
                    checkTB = True
                if fb.GetX() > self.gamePtr.lineOfScrimmageInPixels:
                    checkFB = True
            else:
                if tb.GetX() < self.gamePtr.lineOfScrimmageInPixels:
                    checkTB = True
                if fb.GetX() < self.gamePtr.lineOfScrimmageInPixels:
                    checkFB = True
                
            # have to figure out first: which side of field is being contained?
            offset = 100

            if self.yInit > self.gamePtr.middleOfFieldInPixels:
                if checkTB and tb.GetY() > yGoal:
                    yGoal = tb.GetY() + offset
                if checkFB and fb.GetY() > yGoal:
                    yGoal = fb.GetY() + offset
            else:
                if checkTB and tb.GetY() < yGoal:
                    yGoal = tb.GetY() - offset
                if checkFB and fb.GetY() < yGoal:
                    yGoal = fb.GetY() - offset
        elif self.behavior == 'PassBlock':
            (xGoal, yGoal) = self.CalculateChaseTarget(self.target)
            if self.gamePtr.offenseTeam == 0:
                if xGoal > self.gamePtr.lineOfScrimmageInPixels:
                    xGoal = self.gamePtr.lineOfScrimmageInPixels
            else:
                if xGoal < self.gamePtr.lineOfScrimmageInPixels:
                    xGoal = self.gamePtr.lineOfScrimmageInPixels
        elif self.behavior == 'Block' or self.behavior == 'BlockNearest':
            (xGoal, yGoal) = self.CalculateChaseTarget(self.target)
        elif self.behavior == 'BlockLeft':
            xGoal = self.target.GetX()
            if self.team == 0:
                yGoal = self.target.GetY() - self.target.GetSize()
            else:
                yGoal = self.target.GetY() + self.target.GetSize()
        elif self.behavior == 'BlockRight':
            xGoal = self.target.GetX()
            if self.team == 0:
                yGoal = self.target.GetY() + self.target.GetSize()
            else:
                yGoal = self.target.GetY() - self.target.GetSize()
        elif self.behavior == 'MoveAndJuke':
            if self.team == 0:
                xGoal = self.x + 100.0
            else:
                xGoal = self.x - 100.0
            yGoal = self.y
        elif self.behavior == 'MoveTo':
            xGoal = self.target[0]
            yGoal = self.target[1]
        elif self.behavior == 'MoveToExact':
            xGoal = self.target[0]
            yGoal = self.target[1]
        elif self.behavior == 'Wait':
            xGoal = self.x
            yGoal = self.y
        elif self.behavior == 'EndIf':
            self.GetNextBehavior()
            xGoal = self.x
            yGoal = self.y
        else:
            Abort('not a proper behavior: ' + self.behavior)

        # juke nearby players (do this with magnetics)
        # ATTRACT STRONGLY TO TOUCHDOWN, REPEL FROM NEARBY PLAYERS (BUT ONLY UP OR DOWN)
        if self.followMouse == False and self.behavior == 'MoveAndJuke':
            push = 0
            for other in self.gamePtr.activePlayers:
                if other.ID != self.ID:
                    d = self.GetDist(other.ID)
                    if d < 100.0:
                        ox = other.GetX()
                        oy = other.GetY()
                        if (self.team == 0 and ox > self.x) or (self.team == 1 and ox < self.x):
                            if oy > self.y:
                                push = push - 1
                            else:
                                push = push + 1
            if self.team == 0:
                xGoal = self.x + 100.0
            else:
                xGoal = self.x - 100.0
            yGoal = self.y + (150.0 * push)
            if yGoal > self.fieldPtr.bottomOut:
                yGoal = self.fieldPtr.bottomOut - 10.0
            if yGoal < self.fieldPtr.topOut:
                yGoal = self.fieldPtr.topOut + 10.0
        
        # DEBUG DRAWING TARGET
        # if self.hasBall == True:
        # if self.position == 'C':
        SafeDelete(self.canvas, self.tempID)
        # self.tempID = self.canvas.create_oval(xGoal-3, yGoal-3, xGoal+3, yGoal+3, fill=self.mainColor, width=0)

        # BOUND our goals by the field
        if self.behavior != 'MoveToExact' and self.followMouse == False:
            # one yard is about 11.66 pixels
            bufDst = 45.0 # go for about 4 yards
            if xGoal > self.fieldPtr.rightOut:
                xGoal = self.fieldPtr.rightOut - bufDst
            if xGoal < self.fieldPtr.leftOut:
                xGoal = self.fieldPtr.leftOut + bufDst

            # treat sidelines differently
            bufDst = 20.0 
            if yGoal < self.fieldPtr.topOut:
                yGoal = self.fieldPtr.topOut + bufDst
            if yGoal > self.fieldPtr.bottomOut:
                yGoal = self.fieldPtr.bottomOut - bufDst

        # update vectors ...
        xDiff = xGoal - self.x
        yDiff = yGoal - self.y
        zDiff = math.sqrt((xDiff*xDiff)+(yDiff*yDiff))

        # check if we are close enough just to stop
        if self.followMouse == False and self.behavior == 'MoveTo':
            if zDiff < 40.0:
                self.speed = self.speed / 1.05
                if self.speed < 2.0:
                    self.speed = 2.0
            if zDiff < 10.0:
                self.GetNextBehavior()
                return False

        if self.followMouse == False and self.behavior == 'MoveToExact':
            if zDiff < 100.0:
                self.speed = self.speed / 1.05
                if self.speed < 3.0:
                    self.speed = self.speed - 0.05
                    if self.speed < 2.0:
                        self.speed = 2.0
            if zDiff < 10.0:
                # here, we are done
                self.x = xGoal
                self.y = yGoal
                self.xVec = 0.0
                self.yVec = 0.0
                # 
                self.behavior = 'Wait'
                return True

        # otherwise, just calculate result vector
        ratio = self.maxAccel
        if zDiff != 0:
            ratio = self.maxAccel / zDiff
            
        xGoalVec = ratio * xDiff
        yGoalVec = ratio * yDiff

        xResultVec = xGoalVec + self.xVec
        yResultVec = yGoalVec + self.yVec

        zResultVec = math.sqrt((xResultVec*xResultVec)+(yResultVec*yResultVec))

        if zResultVec > self.speed:
            ratio = self.speed / zResultVec
            xResultVec = xResultVec * ratio
            yResultVec = yResultVec * ratio
            zResultVec = math.sqrt((xResultVec*xResultVec)+(yResultVec*yResultVec))

        # stay away from players on my own team ...
        if self.followMouse == False and self.hasBall == False and self.repulseNum != -1:
            # means someone else is repulsing me (and i am not the ball carrier)
            rx = self.x - self.repulse.x
            ry = self.y - self.repulse.y
            # scale this
            rz = math.sqrt((rx*rx)+(ry*ry))
            if rz > 0.0:
                ratio = self.speed / rz
            else:
                ratio = 1.0
            rx = rx * ratio
            ry = ry * ratio

            xResultVec = xResultVec + rx
            yResultVec = yResultVec + ry

            if rz > 0.0:
                ratio = self.speed / rz
            else:
                ratio = 1.0
            xResultVec = xResultVec * ratio
            yResultVec = yResultVec * ratio

        self.xVec = xResultVec
        self.yVec = yResultVec

        if self.behavior == 'Wait':
            self.xVec = 0.0
            self.yVec = 0.0

        return False

    # Player: Redraw()
    def Redraw(self):
        self.canvas.coords(self.id, self.x-self.size, self.y-self.size, self.x+self.size, self.y+self.size)
        self.canvas.coords(self.textID, self.x, self.y)
        if self.hasBall == True:
            self.ballPtr.Redraw()

    # Player: ClearReplayBuffer()
    def StartRecording(self):
        self.replayRecord = True
        self.replayBuffer = []

    def StopRecording(self):
        self.replayRecord = False

    # Player: Move
    def Move(self):
        self.lastX = self.x
        self.lastY = self.y
        self.x = self.x + self.xVec
        self.y = self.y + self.yVec
        if self.replayRecord == True:
            self.replayBuffer.append((self.x, self.y))
        if self.hasBall == True:
            self.ballPtr.Move(self.x, self.y)

    # Player: MoveBack
    def MoveBack(self, distance):
        self.x = self.lastX
        self.y = self.lastY
        if self.replayRecord == True:
            # remove last entry first
            del self.replayBuffer[len(self.replayBuffer) - 1]
            self.replayBuffer.append((self.x, self.y))
        if self.hasBall == True:
            self.ballPtr.MoveBack(self.x, self.y)

    # Player:
    def Collide(self, distance, other):
        # moveback so as to avoid any possibility of overlap
        # XXX this doesn't work as implemented -- would need to do this
        # with each and every move that takes place ...
        self.MoveBack(distance)
        other.MoveBack(distance)
        self.Redraw()
        other.Redraw()

        # power of collision
        power = self.mass - other.mass

        freezeplay = False

        # tackle counter
        if self.hasBall == True and self.team != other.team:
            self.hits += 1
            if self.hits >= self.mass:
                freezeplay = True
        if other.hasBall == True and self.team != other.team:
            other.hits += 1
            if other.hits >= other.mass:
                freezeplay = True

        # simple momentum calculation: just transfer it directly
        if False:
            # OLD METHOD -- KIND OF BROKEN, KIND OF WORKS WELL
            factor = 1.0
            if self.team == other.GetTeam():
                tmpX = self.xVec
                tmpY = self.yVec
                self.xVec = other.GetYVec()
                self.yVec = other.GetXVec()
                # XXX shouldn't this be tmpY then tmpX?
                other.SetXVec(tmpX)
                other.SetYVec(tmpY)
            else:
                tmpX = self.xVec
                tmpY = self.yVec
                self.xVec = factor * other.GetYVec()
                self.yVec = factor * other.GetXVec()
                # XXX shouldn't this be tmpY then tmpX?
                other.SetXVec(factor * tmpX)
                other.SetYVec(factor * tmpY)

            # plus, add some randomness
            self.doRandom = True
            if self.doRandom == True:
                nangle = math.radians(random.random() * 360.0)
                self.xVec = self.xVec + math.cos(nangle)
                self.yVec = self.yVec + math.sin(nangle)
                nangle = math.radians(random.random() * 360.0)
                other.SetXVec(other.GetXVec() + math.cos(nangle))
                other.SetYVec(other.GetYVec() + math.sin(nangle))

        if False:
            u1x = self.xVec
            u1y = self.yVec
            m1  = self.mass
            u2x = other.GetXVec()
            u2y = other.GetYVec()
            m2  = other.GetMass()

            mp  = (m1-m2)/(m1+m2)
            md  = (2*m2)/(m1+m2)
            v1x = (mp*u1x) + (md*u2x)
            v1y = (mp*u1y) + (md*u2y)
            mp  = (m2-m1)/(m1+m2)
            md  = (2*m1)/(m1+m2)
            v2x = (mp*u2x) + (md*u2x)
            v2y = (mp*u2y) + (md*u2y)

            self.SetXVec(v1x)
            self.SetYVec(v1y)
            other.SetXVec(v2x)
            other.SetYVec(v2y)

        if True:
            tmpX = self.xVec
            tmpY = self.yVec
            self.xVec = other.GetXVec()
            self.yVec = other.GetYVec()
            other.SetXVec(tmpX)
            other.SetYVec(tmpY)

        # plus, add some randomness
        self.doRandom = True
        if self.doRandom == True:
            nangle = math.radians(random.random() * 360.0)
            self.xVec = self.xVec + math.cos(nangle)
            self.yVec = self.yVec + math.sin(nangle)

            nangle = math.radians(random.random() * 360.0)
            other.SetXVec(other.GetXVec() + math.cos(nangle))
            other.SetYVec(other.GetYVec() + math.sin(nangle))

        return freezeplay

# 
# class Formation
#
class Formation:
    def __init__(self, gamePtr, playbookPtr, team):
        self.gamePtr     = gamePtr
        self.playbookPtr = playbookPtr
        self.team        = team
        
        # which formation are we using, right now?
        self.currOffenseFormation = 0
        self.currDefenseFormation = 2

        # where the info is stored
        self.offensiveFormations = {}
        self.defensiveFormations = {}
        self.formationNames      = {}

        self.flip = {}

        mul = 1
        if self.team == 1:
            mul = -1

        # save play
        self.saveFormation = -1

        # I-FORMATION (FB in front)
        f = 0
        self.flip[0] = 0
        self.formationNames[f]  = 'I'
        self.offensiveFormations[(f, 'QB')] = [ {'action':'MoveToExact', 'target':[-4,0]} ]
        self.offensiveFormations[(f, 'FB')] = [ {'action':'MoveToExact', 'target':[-8,0]} ]
        self.offensiveFormations[(f, 'TB')] = [ {'action':'MoveToExact', 'target':[-11,0]} ]
        self.offensiveFormations[(f, 'LG')] = [ {'action':'MoveToExact', 'target':[-1.5,-4*mul]} ]
        self.offensiveFormations[(f, 'C')]  = [ {'action':'MoveToExact', 'target':[-1.2,0]} ]
        self.offensiveFormations[(f, 'RG')] = [ {'action':'MoveToExact', 'target':[-1.5,+4*mul]} ]

        # SPLIT-BACK (FB LEFT)
        f = 1
        self.flip[1] = 8
        self.formationNames[f]  = 'Split Back (FB Left)'
        self.offensiveFormations[(f, 'QB')] = [ {'action':'MoveToExact', 'target':[-4,0]} ]
        self.offensiveFormations[(f, 'FB')] = [ {'action':'MoveToExact', 'target':[-8,-3*mul]} ]
        self.offensiveFormations[(f, 'TB')] = [ {'action':'MoveToExact', 'target':[-8,+3*mul]} ]
        self.offensiveFormations[(f, 'LG')] = [ {'action':'MoveToExact', 'target':[-1.5,-4*mul]} ]
        self.offensiveFormations[(f, 'C')]  = [ {'action':'MoveToExact', 'target':[-1.2,0]} ]
        self.offensiveFormations[(f, 'RG')] = [ {'action':'MoveToExact', 'target':[-1.5,+4*mul]} ]

        # SINGLE-BACK, TB-SPLIT RIGHT
        f = 2
        self.flip[2] = 3
        self.formationNames[f]  = 'Single Back, TB Right'
        self.offensiveFormations[(f, 'QB')] = [ {'action':'MoveToExact', 'target':[-4,0]} ]
        self.offensiveFormations[(f, 'FB')] = [ {'action':'MoveToExact', 'target':[-8,0]} ]
        self.offensiveFormations[(f, 'TB')] = [ {'action':'MoveToExact', 'target':[-1.5,+12*mul]} ]
        self.offensiveFormations[(f, 'LG')] = [ {'action':'MoveToExact', 'target':[-1.5,-4*mul]} ]
        self.offensiveFormations[(f, 'C')]  = [ {'action':'MoveToExact', 'target':[-1.2,0]} ]
        self.offensiveFormations[(f, 'RG')] = [ {'action':'MoveToExact', 'target':[-1.5,+4*mul]} ]

        # SINGLE-BACK, TB-SPLIT LEFT
        f = 3
        self.flip[3] = 2
        self.formationNames[f]  = 'Single Back, TB Left'
        self.offensiveFormations[(f, 'QB')] = [ {'action':'MoveToExact', 'target':[-4,0]} ]
        self.offensiveFormations[(f, 'FB')] = [ {'action':'MoveToExact', 'target':[-8,0]} ]
        self.offensiveFormations[(f, 'TB')] = [ {'action':'MoveToExact', 'target':[-1.5,-12*mul]} ]
        self.offensiveFormations[(f, 'LG')] = [ {'action':'MoveToExact', 'target':[-1.5,-4*mul]} ]
        self.offensiveFormations[(f, 'C')]  = [ {'action':'MoveToExact', 'target':[-1.2,0]} ]
        self.offensiveFormations[(f, 'RG')] = [ {'action':'MoveToExact', 'target':[-1.5,+4*mul]} ]

        # NO-BACK, FB RIGHT as TE, TB-SPLIT RIGHT 
        f = 4
        self.flip[4] = 5
        self.formationNames[f]  = 'No Backs, TB Wide Right, FB Right as Tight End'
        self.offensiveFormations[(f, 'QB')] = [ {'action':'MoveToExact', 'target':[-4  ,+0*mul]} ]
        self.offensiveFormations[(f, 'FB')] = [ {'action':'MoveToExact', 'target':[-3.5,+8*mul]} ]
        self.offensiveFormations[(f, 'TB')] = [ {'action':'MoveToExact', 'target':[-1.5,+18*mul]} ]
        self.offensiveFormations[(f, 'LG')] = [ {'action':'MoveToExact', 'target':[-1.5,-4*mul]} ]
        self.offensiveFormations[(f, 'C')]  = [ {'action':'MoveToExact', 'target':[-1.2,+0*mul]} ]
        self.offensiveFormations[(f, 'RG')] = [ {'action':'MoveToExact', 'target':[-1.5,+4*mul]} ]

        # NO-BACK, FB RIGHT as TE, TB-SPLIT LEFT
        f = 5
        self.flip[5] = 4
        self.formationNames[f]  = 'No Backs, TB Wide Left, FB Left as Tight End'
        self.offensiveFormations[(f, 'QB')] = [ {'action':'MoveToExact', 'target':[-4,0*mul]} ]
        self.offensiveFormations[(f, 'FB')] = [ {'action':'MoveToExact', 'target':[-3.5,-8*mul]} ]
        self.offensiveFormations[(f, 'TB')] = [ {'action':'MoveToExact', 'target':[-1.5,-18*mul]} ]
        self.offensiveFormations[(f, 'LG')] = [ {'action':'MoveToExact', 'target':[-1.5,-4*mul]} ]
        self.offensiveFormations[(f, 'C')]  = [ {'action':'MoveToExact', 'target':[-1.2,0 *mul]} ]
        self.offensiveFormations[(f, 'RG')] = [ {'action':'MoveToExact', 'target':[-1.5,+4*mul]} ]

        # NO-BACK, FB LEFT as TE, TB-SPLIT RIGHT 
        f = 6
        self.flip[6] = 7
        self.formationNames[f]  = 'No Backs, TB Wide Right, FB Right as Tight End'
        self.offensiveFormations[(f, 'QB')] = [ {'action':'MoveToExact', 'target':[-4  ,+0*mul]} ]
        self.offensiveFormations[(f, 'FB')] = [ {'action':'MoveToExact', 'target':[-1.5,-18*mul]} ]
        self.offensiveFormations[(f, 'TB')] = [ {'action':'MoveToExact', 'target':[-1.5,+18*mul]} ]
        self.offensiveFormations[(f, 'LG')] = [ {'action':'MoveToExact', 'target':[-1.5,-4*mul]} ]
        self.offensiveFormations[(f, 'C')]  = [ {'action':'MoveToExact', 'target':[-1.2,+0*mul]} ]
        self.offensiveFormations[(f, 'RG')] = [ {'action':'MoveToExact', 'target':[-1.5,+4*mul]} ]

        # NO-BACK, FB RIGHT as TE, TB-SPLIT LEFT
        f = 7
        self.flip[7] = 6
        self.formationNames[f]  = 'No Backs, TB Wide Left, FB Left as Tight End'
        self.offensiveFormations[(f, 'QB')] = [ {'action':'MoveToExact', 'target':[-4,0*mul]} ]
        self.offensiveFormations[(f, 'FB')] = [ {'action':'MoveToExact', 'target':[-1.5,+18*mul]} ]
        self.offensiveFormations[(f, 'TB')] = [ {'action':'MoveToExact', 'target':[-1.5,-18*mul]} ]
        self.offensiveFormations[(f, 'LG')] = [ {'action':'MoveToExact', 'target':[-1.5,-4*mul]} ]
        self.offensiveFormations[(f, 'C')]  = [ {'action':'MoveToExact', 'target':[-1.2,0 *mul]} ]
        self.offensiveFormations[(f, 'RG')] = [ {'action':'MoveToExact', 'target':[-1.5,+4*mul]} ]

        # SPLIT-BACK (FB RIGHT)
        f = 8
        self.flip[8] = 1
        self.formationNames[f]  = 'Split Back (FB Right)'
        self.offensiveFormations[(f, 'QB')] = [ {'action':'MoveToExact', 'target':[-4,0]} ]
        self.offensiveFormations[(f, 'FB')] = [ {'action':'MoveToExact', 'target':[-8,+3*mul]} ]
        self.offensiveFormations[(f, 'TB')] = [ {'action':'MoveToExact', 'target':[-8,-3*mul]} ]
        self.offensiveFormations[(f, 'LG')] = [ {'action':'MoveToExact', 'target':[-1.5,-4*mul]} ]
        self.offensiveFormations[(f, 'C')]  = [ {'action':'MoveToExact', 'target':[-1.2,0]} ]
        self.offensiveFormations[(f, 'RG')] = [ {'action':'MoveToExact', 'target':[-1.5,+4*mul]} ]

        # PUNT FORMATION
        f = 9
        self.flip[9] = 9
        self.formationNames[f]  = 'Punt Formation'
        self.offensiveFormations[(f, 'QB')] = [ {'action':'MoveToExact', 'target':[-12,0]} ]
        self.offensiveFormations[(f, 'FB')] = [ {'action':'MoveToExact', 'target':[-3,+8*mul]} ]
        self.offensiveFormations[(f, 'TB')] = [ {'action':'MoveToExact', 'target':[-3,-8*mul]} ]
        self.offensiveFormations[(f, 'LG')] = [ {'action':'MoveToExact', 'target':[-1.5,-4*mul]} ]
        self.offensiveFormations[(f, 'C')]  = [ {'action':'MoveToExact', 'target':[-1.2,0]} ]
        self.offensiveFormations[(f, 'RG')] = [ {'action':'MoveToExact', 'target':[-1.5,+4*mul]} ]

        # KICKOFF FORMATION
        # f = 10
        # self.flip[10] = 10
        # self.formationNames[f]  = 'Kickoff Formation (Receive)'
        # self.defensiveFormations[(f, 'RG')] = [ {'action':'MoveToExact', 'target':[+10.5,+14*mul]} ]
        # self.defensiveFormations[(f,  'C')] = [ {'action':'MoveToExact', 'target':[+10.5,+0*mul]} ]
        # self.defensiveFormations[(f, 'LG')] = [ {'action':'MoveToExact', 'target':[+10.5,-14*mul]} ]
        # self.defensiveFormations[(f, 'QB')] = [ {'action':'MoveToExact', 'target':[+24.5,-7*mul]} ]
        # self.defensiveFormations[(f, 'TB')] = [ {'action':'MoveToExact', 'target':[+50.0,0]} ]
        # self.defensiveFormations[(f, 'FB' )] = [ {'action':'MoveToExact', 'target':[+24.5,+7*mul]} ]

        # record max 
        self.maxOffenseFormation = f

        mul = -1
        if self.team == 1:
            mul = 1

        # DEFENSIVE - NORMAL ZONE
        team = 1
        f = 0
        self.formationNames[f]  = 'Normal Zone'
        self.defensiveFormations[(f, 'LT')] = [ {'action':'MoveToExact', 'target':[+1.5,+4*mul]} ]
        self.defensiveFormations[(f, 'NT')] = [ {'action':'MoveToExact', 'target':[+1.5,+0*mul]} ]
        self.defensiveFormations[(f, 'RT')] = [ {'action':'MoveToExact', 'target':[+1.5,-4*mul]} ]
        self.defensiveFormations[(f, 'LB')] = [ {'action':'MoveToExact', 'target':[+12,0*mul]} ]
        self.defensiveFormations[(f, 'CB')] = [ {'action':'MoveToExact', 'target':[+7,+12*mul]} ]
        self.defensiveFormations[(f, 'S' )] = [ {'action':'MoveToExact', 'target':[+7,-12*mul]} ]

        # DEFENSIVE - AGGRESSIVE ZONE
        f = 1
        self.formationNames[f]  = 'Aggressive Zone'
        self.defensiveFormations[(f, 'LT')] = [ {'action':'MoveToExact', 'target':[+1.5,+4*mul]} ]
        self.defensiveFormations[(f, 'NT')] = [ {'action':'MoveToExact', 'target':[+1.5,+0*mul]} ]
        self.defensiveFormations[(f, 'RT')] = [ {'action':'MoveToExact', 'target':[+1.5,-4*mul]} ]
        self.defensiveFormations[(f, 'LB')] = [ {'action':'MoveToExact', 'target':[+6,0*mul]} ]
        self.defensiveFormations[(f, 'CB')] = [ {'action':'MoveToExact', 'target':[+2,+12*mul]} ]
        self.defensiveFormations[(f, 'S' )] = [ {'action':'MoveToExact', 'target':[+2,-12*mul]} ]

        # DEFENSIVE - MAN-2-MAN
        f = 2
        self.formationNames[f]  = 'Man-to-Man'
        self.defensiveFormations[(f, 'LT')] = [ {'action':'MoveToExact', 'target':[+1.5,+4*mul]} ]
        self.defensiveFormations[(f, 'NT')] = [ {'action':'MoveToExact', 'target':[+1.5,+0*mul]} ]
        self.defensiveFormations[(f, 'RT')] = [ {'action':'MoveToExact', 'target':[+1.5,-4*mul]} ]
        self.defensiveFormations[(f, 'LB')] = [ {'action':'MoveToExact', 'target':[+4.5,0*mul]} ]
        self.defensiveFormations[(f, 'CB')] = [ {'action':'MoveToExact', 'target':[+7.5, 'TB'], 'mode':'cover'} ]
        self.defensiveFormations[(f, 'S' )] = [ {'action':'MoveToExact', 'target':[+10.5,'FB'], 'mode':'cover'} ]

        # DEFENSIVE - MAN-2-MAN (LB LEFT)
        f = 3
        self.formationNames[f]  = 'Man-to-Man (LB Left)'
        self.defensiveFormations[(f, 'LT')] = [ {'action':'MoveToExact', 'target':[+1.5,+4*mul]} ]
        self.defensiveFormations[(f, 'NT')] = [ {'action':'MoveToExact', 'target':[+1.5,+0*mul]} ]
        self.defensiveFormations[(f, 'RT')] = [ {'action':'MoveToExact', 'target':[+1.5,-4*mul]} ]
        self.defensiveFormations[(f, 'LB')] = [ {'action':'MoveToExact', 'target':[+4.5,+6*mul]} ]
        self.defensiveFormations[(f, 'CB')] = [ {'action':'MoveToExact', 'target':[+7.5, 'TB'], 'mode':'cover'} ]
        self.defensiveFormations[(f, 'S' )] = [ {'action':'MoveToExact', 'target':[+10.5,'FB'], 'mode':'cover'} ]

        # DEFENSIVE - MAN-2-MAN (LB RIGHT)
        f = 4
        self.formationNames[f]  = 'Man-to-Man (LB Right)'
        self.defensiveFormations[(f, 'LT')] = [ {'action':'MoveToExact', 'target':[+1.5,+4*mul]} ]
        self.defensiveFormations[(f, 'NT')] = [ {'action':'MoveToExact', 'target':[+1.5,+0*mul]} ]
        self.defensiveFormations[(f, 'RT')] = [ {'action':'MoveToExact', 'target':[+1.5,-4*mul]} ]
        self.defensiveFormations[(f, 'LB')] = [ {'action':'MoveToExact', 'target':[+4.5,-6*mul]} ]
        self.defensiveFormations[(f, 'CB')] = [ {'action':'MoveToExact', 'target':[+7.5, 'TB'], 'mode':'cover'} ]
        self.defensiveFormations[(f, 'S' )] = [ {'action':'MoveToExact', 'target':[+10.5,'FB'], 'mode':'cover'} ]

        # KICKOFF FORMATION
        # f = 5
        # self.formationNames[f]  = 'Kickoff Formation (Kick-Off)'
        # self.offensiveFormations[(f, 'LT')] = [ {'action':'MoveToExact', 'target':[0,-10*mul]} ]
        # self.offensiveFormations[(f, 'RT')] = [ {'action':'MoveToExact', 'target':[0,+4*mul]} ]
        # self.offensiveFormations[(f, 'NT')] = [ {'action':'MoveToExact', 'target':[0,+10*mul]} ]
        # self.offensiveFormations[(f, 'LB')] = [ {'action':'MoveToExact', 'target':[-6,-4*mul]} ]
        # self.offensiveFormations[(f, 'CB')] = [ {'action':'MoveToExact', 'target':[0,+18*mul]} ]
        # self.offensiveFormations[(f, 'S')]  = [ {'action':'MoveToExact', 'target':[0,-18*mul]} ]

        # set max
        self.maxDefenseFormation = f

        # now build flipped formations where appropriate
        # (all offenses are relative to going left-to-right, and defenses the opposite)
        if self.team == 1:
            for f in range(0, self.maxOffenseFormation+1):
                for position in self.gamePtr.offensivePlayerPositions:
                    tx = self.offensiveFormations[(f, position)][0]['target'][0]
                    ty = self.offensiveFormations[(f, position)][0]['target'][1]
                    if 'mode' in self.offensiveFormations[(f, position)][0]:
                        mode = self.offensiveFormations[(f, position)][0]['mode']
                        self.offensiveFormations[(f, position)] = [ {'action':'MoveToExact', 'target':[-tx, ty], 'mode':mode} ]
                    else:
                        self.offensiveFormations[(f, position)] = [ {'action':'MoveToExact', 'target':[-tx, ty]} ]

        if self.team == 0:
            for f in range(0, self.maxDefenseFormation+1):
                for position in self.gamePtr.defensivePlayerPositions:
                    tx = self.defensiveFormations[(f, position)][0]['target'][0]
                    ty = self.defensiveFormations[(f, position)][0]['target'][1]
                    if 'mode' in self.defensiveFormations[(f, position)][0]:
                        mode = self.defensiveFormations[(f, position)][0]['mode']
                        self.defensiveFormations[(f, position)] = [ {'action':'MoveToExact', 'target':[-tx, ty], 'mode':mode} ]
                    else:
                        self.defensiveFormations[(f, position)] = [ {'action':'MoveToExact', 'target':[-tx, ty]} ]

        # one last thing formation class does: set bench positions
        self.benchPositions = {}
        yard = -20
        for position in self.gamePtr.offensivePlayerPositions:
            self.benchPositions[position] = yard
            yard = yard + 4
        for position in self.gamePtr.defensivePlayerPositions:
            self.benchPositions[position] = yard
            yard = yard + 4

    # Formation: 
    def Flip(self, play):
        return self.flip[play]

    # Formation: 
    def FlipFormation(self):
        newFormation = self.flip[self.currOffenseFormation]
        self.currOffenseFormation = newFormation
        return

    # Formation: 
    def CopyFormation(self):
        if self.gamePtr.offenseTeam == 0:
            self.saveFormation = self.currOffenseFormation
        else:
            self.saveFormation = self.currDefenseFormation

    # Formation: 
    def PasteFormation(self):
        if self.saveFormation == -1:
            return
        if self.gamePtr.offenseTeam == 0:
            self.SetOffensiveFormation(self.saveFormation)
        else:
            self.SetDefensiveFormation(self.saveFormation)

    # Formation: 
    # this could be fixed to find better bench positions for the players...
    def GetBenchFormation(self, position):
        return [ {'action':'MoveToExact', 'target':[self.benchPositions[position],+27]} ]
    
    # Formation: 
    def GetCurrentOffensiveFormation(self, position):
        return self.offensiveFormations[(self.currOffenseFormation, position)]

    # Formation: 
    def GetCurrentDefensiveFormation(self, position):
        return self.defensiveFormations[(self.currDefenseFormation, position)]

    # Formation: 
    def GetOffensiveFormationByPlay(self, position, play):
        formation = self.playbookPtr.GetOffensiveFormationByPlay(play)
        return self.offensiveFormations[(formation, position)]

    # Formation: 
    def GetDefensiveFormationByPlay(self, position, play):
        formation = self.playbookPtr.GetDefensiveFormationByPlay(play)
        return self.defensiveFormations[(formation, position)]

    # Formation: 
    def SetOffensiveFormation(self, formation):
        assert(formation >= 0 and formation <= self.maxOffenseFormation)
        self.currOffenseFormation = formation

    # Formation: 
    def SetDefensiveFormation(self, formation):
        assert(formation >= 0 and formation <= self.maxDefenseFormation)
        self.currDefenseFormation = formation

    # Formation: 
    def IncrementOffensiveFormation(self):
        if self.currOffenseFormation < self.maxOffenseFormation:
            self.currOffenseFormation = self.currOffenseFormation + 1
        self.playbookPtr.AssociateOffenseFormationWithPlay(self.currOffenseFormation)

    # Formation: 
    def DecrementOffensiveFormation(self):
        if self.currOffenseFormation > 0:
            self.currOffenseFormation = self.currOffenseFormation - 1
        self.playbookPtr.AssociateOffenseFormationWithPlay(self.currOffenseFormation)

    # Formation: 
    def IncrementDefensiveFormation(self):
        if self.currDefenseFormation < self.maxDefenseFormation:
            self.currDefenseFormation = self.currDefenseFormation + 1
        self.playbookPtr.AssociateDefenseFormationWithPlay(self.currDefenseFormation)

    # Formation: 
    def DecrementDefensiveFormation(self):
        if self.currDefenseFormation > 0:
            self.currDefenseFormation = self.currDefenseFormation - 1
        self.playbookPtr.AssociateDefenseFormationWithPlay(self.currDefenseFormation)


#
# class Box
#
# This is the class for each box drawn on the screen
# Does it really need a class? Don't know, but it was
# getting messy without one
#
class Box:
    def __init__(self, fieldPtr, gamePtr, canvas, team, isOffense, box):
        self.fieldPtr  = fieldPtr
        self.gamePtr   = gamePtr
        self.canvas    = canvas
        self.team      = team
        self.isOffense = isOffense

        # box holds the line-of-scrimmage relative coords
        self.box       = box

        # keep raw screen coords handy too
        (self.x1, self.y1, self.x2, self.y2) = self.BoxToPixels(self.team, box)

    # get coords (in LOS-relative form)
    def GetCoords(self):
        return self.box

    def GetCoordsInPixels(self):
        return [self.x1, self.y1, self.x2, self.y2]
        
    # Box:
    def Draw(self):
        if self.isOffense == True:
            self.id = self.canvas.create_rectangle(self.x1, self.y1, self.x2, self.y2, outline='lightblue')
        else:
            self.id = self.canvas.create_rectangle(self.x1, self.y1, self.x2, self.y2, outline='orange', width=2)

    # Box:
    def Undraw(self):
        self.canvas.delete(self.id)

    # Box:
    def Hilite(self):
        if self.isOffense == True:
            self.canvas.itemconfig(self.id, outline='lightblue', width=2)
        else:
            self.canvas.itemconfig(self.id, outline='orange', width=2)


    # Box:
    def Unhilite(self):
        if self.isOffense == True:
            self.canvas.itemconfig(self.id, outline='lightblue', width=1)
        else:
            self.canvas.itemconfig(self.id, outline='orange', width=1)

    # Box: 
    def BoxToPixels(self, team, box):
        if team == 0:
            x1 = self.gamePtr.lineOfScrimmageInPixels + self.fieldPtr.ScaleX(box[0])  
            y1 = self.gamePtr.middleOfFieldInPixels   + self.fieldPtr.ScaleY(box[1]) 
            x2 = self.gamePtr.lineOfScrimmageInPixels + self.fieldPtr.ScaleX(box[2]) 
            y2 = self.gamePtr.middleOfFieldInPixels   + self.fieldPtr.ScaleY(box[3]) 
        else:
            x1 = self.gamePtr.lineOfScrimmageInPixels - self.fieldPtr.ScaleX(box[0])  
            y1 = self.gamePtr.middleOfFieldInPixels   - self.fieldPtr.ScaleY(box[1]) 
            x2 = self.gamePtr.lineOfScrimmageInPixels - self.fieldPtr.ScaleX(box[2]) 
            y2 = self.gamePtr.middleOfFieldInPixels   - self.fieldPtr.ScaleY(box[3]) 
        return (x1, y1, x2, y2)

    # Box: InBox()
    def InBox(self, x, y):
        if Between(x, self.x1, self.x2) and Between(y, self.y1, self.y2):
            return True
        return False

    # Box: InBox()
    def InUpperRightOfBox(self, x, y):
        if self.x2 > self.x1:
            self.hiX = self.x2
        else:
            self.hiX = self.x1
        self.midX = (self.x1 + self.x2) / 2.0
        if self.y1 < self.y2:
            self.loY  = self.y1
        else:
            self.loY  = self.y2
        self.midY = self.loY + 20
        if x > self.midX and x < self.hiX and y > self.loY and y < self.midY:
            return True
        return False

    # Box: InUpperLeftOfBox()
    def InUpperLeftOfBox(self, x, y):
        if self.x2 < self.x1:
            self.loX = self.x2
        else:
            self.loX = self.x1
        self.midX = (self.x1 + self.x2) / 2.0
        if self.y1 < self.y2:
            self.loY  = self.y1
        else:
            self.loY  = self.y2
        self.midY = self.loY + 20
        if x > self.loX and x < self.midX and y > self.loY and y < self.midY:
            return True
        return False

#
# class Playbook
# 
# just holds all the plays
# assumes the caller knows the play number and their essential meaning
#
class Playbook:
    def __init__(self, gamePtr, fieldPtr, team, canvas):
        self.gamePtr       = gamePtr
        self.fieldPtr      = fieldPtr
        self.team          = team
        self.canvas        = canvas
        
        self.currOffense = 0
        self.currDefense = 0

        self.maxOffense = 99
        self.maxDefense = 99

        self.maxOffensivePlay = 0
        self.maxDefensivePlay = 0

        self.offensivePlays = {}
        self.defensivePlays = {}

        self.savePlay = 0

        # use this to associate formations with plays
        # that way, when you switch plays, you end up with the right formation ...
        self.offensiveFormations = {}
        self.defensiveFormations = {}

        # boxes
        self.offensiveBoxes = {}
        self.defensiveBoxes = {}
        self.offensiveBoxIDs = []
        self.defensiveBoxIDs = []

        for play in range(0,self.maxOffense+1):
            self.offensiveBoxes[play] = []
        for play in range(0,self.maxDefense+1):
            self.defensiveBoxes[play] = []

        # init all offensive plays to waiting and doing nothing...
        for play in range(0,self.maxOffense+1):
            self.offensiveFormations[play] = 0
            for position in self.gamePtr.offensivePlayerPositions:
                self.offensivePlays[(play, position)] = [ {'action':'Wait', 'target':''} ]

        # set all defensive plays to the same thing ...
        for play in range(0,self.maxDefense+1):
            self.defensiveFormations[play] = 2
            if play < 1:
                for team in [0, 1]:
                    self.defensivePlays[(play,'RT')]    = [ {'action':'Chase',    'target':'ball'} ]
                    self.defensivePlays[(play,'NT')]    = [ {'action':'Lateral',  'target':'ball'} ]
                    self.defensivePlays[(play,'LT')]    = [ {'action':'Chase',    'target':'ball'} ]
                    self.defensivePlays[(play,'LB')]    = [ {'action':'Lateral',  'target':'ball'} ]
                    self.defensivePlays[(play,'S')]     = [ {'action':'Cover',    'target':'FB'} ]
                    self.defensivePlays[(play,'CB')]    = [ {'action':'Cover',    'target':'TB'} ]
            else:
                for position in self.gamePtr.defensivePlayerPositions:
                    self.defensivePlays[(play, position)] = [ {'action':'Wait', 'target':''} ]

        # save play
        self.savePlay = -1

    # Playbook: AddOffensiveBox()
    def AddOffensiveBox(self, x1, y1, x2, y2):
        # first, check if UNIQUE!
        if [x1, y1, x2, y2] not in self.offensiveBoxes[self.currOffense]:
            self.offensiveBoxes[self.currOffense].append([x1, y1, x2, y2])
        else:
            Nop()
            print 'TRYING TO ADD REDUNDANT BOX!'
        print 'AddOffensiveBox(): ADDED BOX', x1, y1, x2, y2, 'to', self.offensiveBoxes[self.currOffense]

    # Playbook: AddDefensiveBox()
    def AddDefensiveBox(self, x1, y1, x2, y2):
        if [x1, y1, x2, y2] not in self.defensiveBoxes[self.currDefense]:
            self.defensiveBoxes[self.currDefense].append([x1, y1, x2, y2])
        else:
            Nop()
            print 'TRYING TO ADD REDUNDANT BOX!'
        print 'AddDefensiveBox(): ADDED BOX', x1, y1, x2, y2, 'to', self.defensiveBoxes[self.currDefense]

    def DeleteOffensiveBox(self, boxPtr):
        boxPtr.Undraw()
        for index in range(0, len(self.offensiveBoxes[self.currOffense])):
            if self.offensiveBoxes[self.currOffense][index] == boxPtr.GetCoords():
                del self.offensiveBoxes[self.currOffense][index]
                break
        for index in range(0, len(self.offensiveBoxIDs)):
            if self.offensiveBoxIDs[index] == boxPtr:
                del self.offensiveBoxIDs[index]
                break
        del boxPtr

    def DeleteDefensiveBox(self, boxPtr):
        boxPtr.Undraw()
        for index in range(0, len(self.defensiveBoxes[self.currDefense])):
            if self.defensiveBoxes[self.currDefense][index] == boxPtr.GetCoords():
                del self.defensiveBoxes[self.currDefense][index]
                break
        for index in range(0, len(self.defensiveBoxIDs)):
            if self.defensiveBoxIDs[index] == boxPtr:
                del self.defensiveBoxIDs[index]
                break
        del boxPtr

    # Playbook: 
    def GetOffensiveBoxes(self):
        return self.offensiveBoxIDs

    # Playbook: 
    def GetDefensiveBoxes(self):
        return self.defensiveBoxIDs

    # Playbook:
    def DrawOffensiveBoxes(self):
        for box in self.offensiveBoxes[self.currOffense]:
            boxPtr = Box(self.fieldPtr, self.gamePtr, self.canvas, self.team, True, box)
            # print 'DrawOffensiveBoxes(): create boxPtr', boxPtr
            boxPtr.Draw()
            self.offensiveBoxIDs.append(boxPtr)
        #print 'DrawOffensiveBoxes(): ADD FINAL LIST (offensiveBoxIDs)', len(self.offensiveBoxIDs), self.offensiveBoxIDs

    # Playbook:
    def UndrawOffensiveBoxes(self):
        for boxPtr in self.offensiveBoxIDs:
            boxPtr.Undraw()
            # print 'UndrawOffensiveBoxes(): delete boxPtr', boxPtr
            del boxPtr
        self.offensiveBoxIDs = []
        #print 'UndrawOffensiveBoxes(): Final List', self.offensiveBoxIDs

    # Playbook:
    def DrawDefensiveBoxes(self):
        for box in self.defensiveBoxes[self.currDefense]:
            # print '--> BOX', self.currDefense, box
            boxPtr = Box(self.fieldPtr, self.gamePtr, self.canvas, self.team, False, box)
            # print 'DrawDefensiveBoxes(): create boxPtr', boxPtr
            boxPtr.Draw()
            self.defensiveBoxIDs.append(boxPtr)
        # print 'DrawDefensiveBoxes(): ADD FINAL LIST (defensiveBoxIDs)', len(self.defensiveBoxIDs), self.defensiveBoxIDs

    # Playbook:
    def UndrawDefensiveBoxes(self):
        for boxPtr in self.defensiveBoxIDs:
            boxPtr.Undraw()
            # print 'UndrawDefensiveBoxes(): delete boxPtr', boxPtr
            del boxPtr
        self.defensiveBoxIDs = []
        # print 'UndrawOffensiveBoxes(): Final List', self.defensiveBoxIDs

    # Playbook:
    # final initialization step ...
    def SetFormationPtr(self, formationPtr):
        self.formationPtr = formationPtr
        self.SetOffensivePlay(0)
        self.SetDefensivePlay(0)
    
    # Playbook:
    # call this when other team has the ball
    def ReverseBehavior(self, oldBehavior):
        newBehavior = []
        for oldAction in oldBehavior:
            newAction = dict.copy(oldAction)
            if oldAction['action'] == 'MoveTo' or oldAction == 'MoveAndJuke':
                newAction['target'] = [ -oldAction['target'][0], -oldAction['target'][1] ]
            newBehavior.append(newAction)
        return newBehavior

    # Playbook:
    def GetMaxOffensivePlay(self):
        return self.maxOffensivePlay

    # Playbook:
    def GetMaxDefensivePlay(self):
        return self.maxDefensivePlay

    # Playbook:
    def SaveDefense(self):
        self.DoSave(self.defensivePlaybookFile, self.maxDefense, self.defensiveFormations, self.gamePtr.defensivePlayerPositions, self.defensivePlays, self.defensiveBoxes)

    # Playbook:
    def SaveOffense(self):
        self.DoSave(self.offensivePlaybookFile, self.maxOffense, self.offensiveFormations, self.gamePtr.offensivePlayerPositions, self.offensivePlays, self.offensiveBoxes)
        
    # Playbook:
    def DoSave(self, outFile, max, formations, playerPositions, thePlays, theBoxes):
        filename = tempfile.mktemp('.txt')
        fd = open(filename, 'w')
        for play in range(0, max):
            outStr = 'FORMATION %d PLAY %d\n' % (formations[play], play)
            fd.write(outStr)

            outStr = 'BOXES PLAY %d ' % (play)
            fd.write(outStr)
            for box in theBoxes[play]:
                outStr = 'BOX %s %s %s %s END ' % (str(box[0]), str(box[1]), str(box[2]), str(box[3]))
                fd.write(outStr)
            outStr = '\n'
            fd.write(outStr)
            
            for position in playerPositions:
                behavior = thePlays[(play, position)]
                outStr = 'PLAY ' + str(play) + ' POSITION ' + '%2s' % str(position) + ' BEHAVIOR '
                for action in behavior:
                    outStr = outStr + ' ACTION ' + '%10s' % str(action['action']) 
                    t = action['target']
                    if isinstance(t, list):
                        listStr = str(action['target'][0]) + ','
                        tmpLen  = len(action['target'])
                        for index in range(1, tmpLen - 1):
                            listStr += str(action['target'][index]) + ','
                        listStr += str(action['target'][tmpLen-1]) 
                        # (str(action['target'][0]) + ',' + str(action['target'][1]))
                        outStr = outStr + ' TARGET LIST ' + listStr
                    elif isinstance(t, str):
                        if action['target'] == '':
                            action['target'] = 'EMPTY'
                        outStr = outStr + ' TARGET STR  ' + '%9s' % str(action['target'])
                    else:
                        Abort('** internal error saving playbook, aborting **')

                fd.write(outStr + '\n')
        fd.close()
        os.rename(filename, outFile)

    # Playbook:
    def LoadDefense(self, playbook):
        self.defensivePlaybookFile = playbook
        self.maxDefensivePlay = self.DoLoad(self.defensivePlaybookFile, self.defensivePlays, self.defensiveFormations, self.defensiveBoxes)

    # Playbook:
    def LoadOffense(self, playbook):
        self.offensivePlaybookFile = playbook
        self.maxOffensivePlay = self.DoLoad(self.offensivePlaybookFile, self.offensivePlays, self.offensiveFormations, self.offensiveBoxes)

    # Playbook:
    def DoLoad(self, playbook, playArray, formationArray, boxArray):
        maxPlay = 0
        fd = open(playbook, 'r')
        for line in fd:
            tmp  = line.split()
            if tmp[0] == 'PLAY':
                play     = int(tmp[1])
                position = str(tmp[3])
                curr = 5
                behaviorList = []
                justWaiting = True
                while curr < len(tmp):
                    assert(tmp[curr] == 'ACTION')
                    action = str(tmp[curr+1])
                    if action != 'Wait':
                        justWaiting = False
                    assert(tmp[curr+2] == 'TARGET')
                    if tmp[curr+3] == 'LIST':
                        pieces = tmp[curr+4].split(',')
                        target = []
                        for p in pieces:
                            target.append(float(p))
                    elif tmp[curr+3] == 'STR':
                        target = str(tmp[curr+4])
                    behavior = { 'action':action, 'target':target }
                    behaviorList.append(behavior)
                    curr = curr + 5
                if justWaiting == False:
                    if play > maxPlay:
                        maxPlay = play
                if self.team == 0:
                    playArray[(play, position)] = behaviorList
                else:
                    playArray[(play, position)] = self.ReverseBehavior(behaviorList)
            elif tmp[0] == 'FORMATION':
                formation = int(tmp[1])
                play      = int(tmp[3])
                formationArray[play] = formation
            elif tmp[0] == 'BOXES':
                play = int(tmp[2])
                curr = 4
                while (curr < len(tmp)):
                    x1 = float(tmp[curr])
                    y1 = float(tmp[curr+1])
                    x2 = float(tmp[curr+2])
                    y2 = float(tmp[curr+3])
                    curr += 6
                    if [x1, y1, x2, y2] in boxArray[play]:
                        Nop()
                        # print 'REDUNDANT BOX!'
                    if [x1, y1, x2, y2] not in boxArray[play]:
                        boxArray[play].append([x1, y1, x2, y2])
            else:
                print('bad line in playbook, skipping (%s)' % line)
        return maxPlay

    # Playbook:
    def CopyPlay(self):
        if self.gamePtr.offenseTeam == 0:
            self.savePlay = self.currOffense
        else:
            self.savePlay = self.currDefense
        # print 'SAVED PLAY', self.savePlay

    # Playbook:
    def PastePlay(self):
        if self.savePlay == -1:
            return
        # first do the play itself (each player's actions and such)
        if self.gamePtr.offenseTeam == 0:
            for position in self.gamePtr.offensivePlayerPositions:
                self.offensivePlays[(self.currOffense, position)] = copy.deepcopy(self.offensivePlays[(self.savePlay, position)])
        else:
            for position in self.gamePtr.defensivePlayerPositions:
                self.defensivePlays[(self.currDefense, position)] = copy.deepcopy(self.defensivePlays[(self.savePlay, position)])

        # and now, do the boxes
        if self.gamePtr.offenseTeam == 0:
            self.offensiveBoxes[self.currOffense] = []
            for box in self.offensiveBoxes[self.savePlay]:
                self.offensiveBoxes[self.currOffense].append(box)
        else:
            self.offensiveBoxes[self.currDefense] = []
            for box in self.defensiveBoxes[self.savePlay]:
                self.defensiveBoxes[self.currDefense].append(box)

    # Playbook:
    # this flips the play (and formation) mirror along the x-axis
    # probably needs to be updated for zones, etc.
    def FlipPlay(self):
        for position in self.gamePtr.offensivePlayerPositions:
            if position == 'LG':
                oppositePosition = 'RG'
            elif position == 'RG':
                oppositePosition = 'LG'
            else:
                oppositePosition = position
            oldBehavior = self.offensivePlays[(self.currOffense, oppositePosition)]
            newBehavior = []
            for oldAction in oldBehavior:
                newAction = copy.deepcopy(oldAction)
                if oldAction['action'] == 'MoveTo' or oldAction == 'MoveAndJuke' or oldAction == 'ThrowPosition' or oldAction == 'Punt':
                    newAction['target'] = [ oldAction['target'][0], -oldAction['target'][1] ]
                if oldAction['action'] == 'BlockLeft':
                    newAction['action'] = 'BlockRight'
                if oldAction['action'] == 'BlockRight':
                    newAction['action'] = 'BlockLeft'
                newBehavior.append(newAction)
            self.offensivePlays[(self.currOffense, position)] = newBehavior
        return

    # Playbook:
    def AssociateOffenseFormationWithPlay(self, formation):
        self.offensiveFormations[self.currOffense] = formation
        
    # Playbook:
    def AssociateDefenseFormationWithPlay(self, formation):
        self.defensiveFormations[self.currDefense] = formation
        
    # Playbook:
    def UpdateOffensivePlay(self, position, behavior, reverse):
        if reverse == False:
            self.offensivePlays[(self.currOffense, position)] = behavior
        else:
            self.offensivePlays[(self.currOffense, position)] = self.ReverseBehavior(behavior)
        self.formationPtr.SetOffensiveFormation(self.offensiveFormations[self.currOffense])

    # Playbook:
    def UpdateDefensivePlay(self, position, behavior, reverse):
        if reverse == False:
            self.defensivePlays[(self.currDefense, position)] = behavior
        else:
            self.defensivePlays[(self.currDefense, position)] = self.ReverseBehavior(behavior)
        self.formationPtr.SetDefensiveFormation(self.defensiveFormations[self.currDefense])

    # Playbook:
    def GetDefensivePlayNumber(self):
        return self.currDefense

    # Playbook:
    def GetDefensiveFormationNumber(self):
        return self.formationPtr.currDefenseFormation

    # Playbook:
    def GetOffensivePlayNumber(self):
        return self.currOffense

    # Playbook:
    def GetOffensiveFormationNumber(self):
        return self.formationPtr.currOffenseFormation

    # Playbook:
    def GetCurrentOffensivePlay(self, position):
        return self.offensivePlays[(self.currOffense, position)]

    # Playbook:
    def GetCurrentDefensivePlay(self, position):
        return self.defensivePlays[(self.currDefense, position)]

    # Playbook:
    def GetOffensivePlay(self, position, play):
        return self.offensivePlays[(play, position)]

    # Playbook:
    def GetDefensivePlay(self, position, play):
        return self.defensivePlays[(play, position)]

    # Playbook:
    def SetDefensivePlay(self, play):
        self.currDefense = play
        self.formationPtr.SetDefensiveFormation(self.defensiveFormations[play])

    # Playbook:
    def SetOffensivePlay(self, play):
        self.currOffense = play
        self.formationPtr.SetOffensiveFormation(self.offensiveFormations[play])

    # Playbook:
    def GetOffensiveFormationByPlay(self, play):
        return self.offensiveFormations[play]

    # Playbook:
    def GetDefensiveFormationByPlay(self, play):
        return self.defensiveFormations[play]

    # Playbook:
    def IncrementOffensivePlay(self):
        if self.currOffense < self.maxOffense:
            self.currOffense = self.currOffense + 1
        self.SetOffensivePlay(self.currOffense)

    # Playbook:
    def DecrementOffensivePlay(self):
        if self.currOffense > 0:
            self.currOffense = self.currOffense - 1
        self.SetOffensivePlay(self.currOffense)

    # Playbook:
    def IncrementDefensivePlay(self):
        if self.currDefense < self.maxDefense:
            self.currDefense = self.currDefense + 1
        self.SetDefensivePlay(self.currDefense)
    
    # Playbook:
    def DecrementDefensivePlay(self):
        if self.currDefense > 0:
            self.currDefense = self.currDefense - 1
        self.SetDefensivePlay(self.currDefense)
    

class Game:
    def __init__(self, root, canvas, controller, fieldPtr, scoreboardPtr, timer, leftTeam, rightTeam, homeGame, sound, initTime, autoPick):
        self.root          = root
        self.canvas        = canvas
        self.controller    = controller
        self.fieldPtr      = fieldPtr
        self.scoreboardPtr = scoreboardPtr
        self.timer         = timer
        self.leftTeam      = leftTeam
        self.rightTeam     = rightTeam
        self.homeGame      = homeGame
        self.sound         = sound
        self.initTime      = initTime
        self.autoPick      = autoPick

        self.inControl       = -1
        self.inControlAtHike = -1

        self.allowHike       = True

        # practice mode: on or off (must be before scoreboard gameptr passing)
        self.practiceMode = False
        if self.leftTeam == self.rightTeam:
            self.practiceMode = True

        # team 0: team under your control, team 1: team under computer control
        if self.homeGame == True:
            self.offenseTeam = 0
            self.defenseTeam = 1
        else:
            self.offenseTeam = 1
            self.defenseTeam = 0

        # let scoreboard know about us...
        self.scoreboardPtr.SetGamePtr(gamePtr=self)

        # per-play state
        self.hasBallBeenPassed   = False
        self.pastLineOfScrimmage = False

        self.StateMoveToPosition = 0
        self.StatePlayInAction   = 1
        self.StateWaitingToHike  = 2
        self.StateFrozen         = 3
        self.StateGameOver       = 4

        w = self.fieldPtr.GetHeight()

        self.ticks = 0

        # MAKE LINE OF SCRIMMAGE
        self.lineOfScrimmageID = -1
        self.firstDownLineID   = -1

        self.InitLineOfScrimmage()
        self.FirstDown()

        # this is generic
        self.middleOfField = 27.0
        self.middleOfFieldInPixels  = self.middleOfField  * self.fieldPtr.pixelsPerYard

        # draw ball at line of scrimmage
        self.ballPtr = Ball(fieldPtr=self.fieldPtr, gamePtr=self, canvas=self.canvas, x=self.lineOfScrimmage, y=self.middleOfField)
        self.controller.SetBallPtr(self.ballPtr)

        # INITIAL THING: MUST MAKE SOME PLAYERS
        self.offensivePlayerPositions = ['QB', 'FB', 'TB', 'LG', 'C', 'RG']
        self.defensivePlayerPositions = ['LB', 'S', 'CB', 'NT', 'LT', 'RT']

        self.teamColors  = {}
        self.teamInfo    = {}

        # load the teams from disk
        self.LoadTeam(0, 'Teams/' + self.leftTeam + '/team')
        self.LoadTeam(1, 'Teams/' + self.rightTeam + '/team')

        self.scoreboardPtr.SetLeftTeam(self.leftTeam)
        self.scoreboardPtr.SetRightTeam(self.rightTeam)

        self.playersByPosition = {}
        self.players           = []   # players tracks all players (a simple list of Player objects)
        self.activePlayers     = []   # active players is a subset of players; it is those players who are on the field at a given time
        self.benchedPlayers    = []   # benched is all players minus active players

        # after teams have been loaded, need to create players, send them to their proper locales
        for team in [0, 1]:
            if (team == 0 and self.homeGame == True) or (team == 1 and self.homeGame == False):
                color   = self.teamColors[(team, 'hcolor')]
                outline = self.teamColors[(team, 'houtline')]
                text    = self.teamColors[(team, 'hnumber')]
            else:
                color   = self.teamColors[(team, 'acolor')]
                outline = self.teamColors[(team, 'aoutline')]
                text    = self.teamColors[(team, 'anumber')]
            
            for pos in self.offensivePlayerPositions:
                speed         = float(self.teamInfo[(team, pos)]['speed'])
                accel         = float(self.teamInfo[(team, pos)]['accel'])
                mass          = float(self.teamInfo[(team, pos)]['mass'])
                throwAccuracy = float(self.teamInfo[(team, pos)]['taccuracy'])
                throwSpeed    = float(self.teamInfo[(team, pos)]['tspeed'])
                throwDist     = float(self.teamInfo[(team, pos)]['tdist'])
                newPlayer = Player(gamePtr=self, fieldPtr=fieldPtr, canvas=self.canvas, ballPtr=self.ballPtr, controller=self.controller,
                                   team=team, position=pos, x=0, y=0, accel=accel, speed=speed, mass=mass,
                                   throwAccuracy=throwAccuracy, throwSpeed=throwSpeed, throwDist=throwDist, 
                                   mainColor=color, outlineColor=outline, textColor=text)
                self.playersByPosition[(team, pos)] = newPlayer
                self.players.append(newPlayer)
                if team == self.offenseTeam:
                    self.activePlayers.append(newPlayer)
                else:
                    self.benchedPlayers.append(newPlayer)
            for pos in self.defensivePlayerPositions:
                speed         = float(self.teamInfo[(team, pos)]['speed'])
                accel         = float(self.teamInfo[(team, pos)]['accel'])
                mass          = float(self.teamInfo[(team, pos)]['mass'])
                throwAccuracy = float(self.teamInfo[(team, pos)]['taccuracy'])
                throwSpeed    = float(self.teamInfo[(team, pos)]['tspeed'])
                throwDist     = float(self.teamInfo[(team, pos)]['tdist'])
                newPlayer = Player(gamePtr=self, fieldPtr=fieldPtr, canvas=self.canvas, ballPtr=self.ballPtr, controller=self.controller,
                                   team=team, position=pos, x=0, y=0, accel=accel, speed=speed, mass=mass,
                                   throwAccuracy=throwAccuracy, throwSpeed=throwSpeed, throwDist=throwDist, 
                                   mainColor=color, outlineColor=outline, textColor=text)
                self.playersByPosition[(team, pos)] = newPlayer
                self.players.append(newPlayer)
                if team == self.defenseTeam:
                    self.activePlayers.append(newPlayer)
                else:
                    self.benchedPlayers.append(newPlayer)

        # this will allow us to move everybody ...
        self.doingBenchChange    = True
        self.newlyActivePlayers  = list(self.activePlayers)
        self.newlyBenchedPlayers = list(self.benchedPlayers)

        # make everyone move to some spot, and then redeclare who is active and who isn't
        for player in self.benchedPlayers:
            self.activePlayers.append(player)

        # set player ID as position in players list
        for i in range(0, len(self.players)):
            self.players[i].SetID(i)

        # INITIAL GOAL: MOVE TO A POSITION
        self.doneCount  = 0
        self.numPlayers = len(self.players)

        self.down = 1
        self.togo = 10
        self.scoreboardPtr.UpdateDownDistance(self.down, self.togo)

        # initial play position
        self.playbookPtr  = {}
        self.formationPtr = {}

        # set playbook pointers 
        self.playbookPtr[0] = Playbook(gamePtr=self, fieldPtr=self.fieldPtr, team=0, canvas=self.canvas)
        self.playbookPtr[0].LoadOffense('Teams/' + self.leftTeam + '/offense')
        self.playbookPtr[0].LoadDefense('Teams/' + self.leftTeam + '/defense')
        self.formationPtr[0] = Formation(gamePtr=self, playbookPtr=self.playbookPtr[0], team=0)
        self.playbookPtr[0].SetFormationPtr(self.formationPtr[0])

        self.playbookPtr[1] = Playbook(gamePtr=self, fieldPtr=self.fieldPtr, team=1, canvas=self.canvas)
        self.playbookPtr[1].LoadOffense('Teams/' + self.rightTeam + '/offense')
        self.playbookPtr[1].LoadDefense('Teams/' + self.rightTeam + '/defense')
        self.formationPtr[1] = Formation(gamePtr=self, playbookPtr=self.playbookPtr[1], team=1)
        self.playbookPtr[1].SetFormationPtr(self.formationPtr[1])

        # tell controller about the playbooks
        self.controller.SetPlaybookPtr(self.playbookPtr[0])

        # stats
        self.playCounter          = 1
        self.yardsGained          = [0.0, 0.0]
        self.yardsGainedByPassing = [0.0, 0.0]
        self.yardsGainedByRunning = [0.0, 0.0]
        self.yardsGainedPerPlay   = {}
        self.numTimesPlayUsed     = {}

        self.offYardTotals = {}
        self.offPlayTotals = {}
        self.offIntTotals  = {}
        self.defYardTotals = {}
        self.defPlayTotals = {}
        self.defIntTotals  = {}

        for team in [0, 1]:
            for play in range(0, 1000):
                self.yardsGainedPerPlay[(team, play)] = 0
                self.numTimesPlayUsed[(team, play)]   = 0
                self.offYardTotals[(team, play)] = 0
                self.offPlayTotals[(team, play)] = 0
                self.offIntTotals[(team, play)]  = 0
                self.defYardTotals[(team, play)] = 0
                self.defPlayTotals[(team, play)] = 0
                self.defIntTotals[(team, play)]  = 0

        # now read in stats file for the computer team
        if self.practiceMode == False:
            self.leftHistoryFile = 'Teams/' + self.leftTeam + '/history.' + self.rightTeam
            self.rightHistoryFile = 'Teams/' + self.rightTeam + '/history.' + self.leftTeam
            self.ReadHistoryFile(0, self.leftHistoryFile)
            self.ReadHistoryFile(1, self.rightHistoryFile)

        # Little Play: for better play selection using a little play box at bottom of screen
        self.InitLittlePlay()

        # pick first computer play
        if self.autoPick == True:
            self.PickComputerPlay(0)
        self.PickComputerPlay(1)

        # move players onto field...
        self.SetupPlay()

        # some other state for the game
        self.intercepted         = False
        self.punted              = False
        self.ballDownedAfterPunt = False
        self.lossOnDowns         = False
        self.delayOfGame         = False
        self.passStart           = False
        self.puntStart           = False
        self.halfOver            = False
        self.gameOver            = False
        self.toggle              = False

        # time in game?
        self.halfLengthMins = 2
        self.halfLengthSecs = 30
        self.scoreboardPtr.ResetClock(self.halfLengthMins, self.halfLengthSecs)

        # some info for the user
        self.scoreboardPtr.LogText('Let the Game Begin!')
        self.scoreboardPtr.Flash('Welcome to Five-Minute Football!', 5000)
        self.scoreboardPtr.Flash('by Remzi Arpaci-Dusseau', 5000, 20)
        if self.practiceMode == True:
            self.scoreboardPtr.Flash('-', 5000, 20)
            self.scoreboardPtr.Flash('(Practice Mode)', 5000)

        # NOW, MUST SET UP BEGINNING OF GAME: FROM SIDELINE TO POSITION OF PLAY 0
        self.lastClock = 0
        self.lastTicks = 0

        # pause and replay state
        self.paused             = False
        self.doReplay           = False
        self.replayHaveRecorded = False

        # set up animation loop
        self.root.after(self.timer, self.Animate)

        # hack for final status message not to repeat itself
        self.flashed = False

    # Game: WriteHistoryFile()
    def WriteHistoryFile(self, team, hfile):
        try:
            fd = open(hfile, 'w')
            # write out offensive files first
            fd.write('# offensive plays\n')
            for play in range(self.playbookPtr[team].GetMaxOffensivePlay() + 1):
                fd.write('1 %d %d %d %d\n' % (play, self.offPlayTotals[(team, play)], self.offYardTotals[(team, play)], self.offIntTotals[(team, play)]))
            fd.write('# defensive plays\n')
            for play in range(self.playbookPtr[team].GetMaxDefensivePlay() + 1):
                fd.write('0 %d %d %d %d\n' % (play, self.defPlayTotals[(team, play)], self.defYardTotals[(team, play)], self.defIntTotals[(team, play)]))
            fd.close()
        except:
            print 'Warning: Failed to write history file (%s)' % hfile
                
    # Game: ReadHistoryFile()
    def ReadHistoryFile(self, team, hfile):
        try:
            fd = open(hfile)
        except:
            # no history file -- that's ok, just don't do anything
            print 'Warning: No such history file::', hfile
            return
        
        for line in fd:
            # format: offense? play plays yards ints
            tmp = line.split()
            off   = tmp[0]
            if off == '#':
                continue
            play  = int(tmp[1])
            plays = float(tmp[2])
            yards = float(tmp[3])
            ints  = int(tmp[4])

            if off == '1':
                # this is an offensive play
                self.offPlayTotals[(team, play)] = plays
                self.offYardTotals[(team, play)] = yards
                self.offIntTotals[(team, play)]  = ints
            else:
                self.defPlayTotals[(team, play)] = plays
                self.defYardTotals[(team, play)] = yards
                self.defIntTotals[(team, play)]  = ints
        fd.close()
        
    # Game: LoadTeam()
    def LoadTeam(self, teamNumber, teamFile):
        try:
            fd = open(teamFile)
            for line in fd:
                tmp = line.split()
                if len(tmp) == 0 or tmp[0] == '#':
                    continue
                if tmp[0] == 'colors':
                    if len(tmp) != 7:
                        Abort('bad color line' + line)
                    self.teamColors[(teamNumber, 'hcolor')]   = tmp[1]
                    self.teamColors[(teamNumber, 'houtline')] = tmp[2]
                    self.teamColors[(teamNumber, 'hnumber')]  = tmp[3]
                    self.teamColors[(teamNumber, 'acolor')]   = tmp[4]
                    self.teamColors[(teamNumber, 'aoutline')] = tmp[5]
                    self.teamColors[(teamNumber, 'anumber')]  = tmp[6]
                elif tmp[0] == 'player':
                    self.teamInfo[(teamNumber, tmp[1])]  = {'speed':tmp[2], 'accel':tmp[3], 'mass':tmp[4], 'taccuracy':tmp[5], 'tspeed':tmp[6], 'tdist':tmp[7]}
                else:
                    Abort('** Bad line in team file (%s) **' % self.home)
            fd.close()
        except:
            Abort('No such team -> ' + teamFile)

    # Game:
    def InitLineOfScrimmage(self):
        if self.offenseTeam == 0:
            self.lineOfScrimmage = 20
            self.firstDownLine   = 30
        else:
            self.lineOfScrimmage = 80
            self.firstDownLine   = 70
        self.lineOfScrimmageInPixels = self.fieldPtr.ScaleX(self.lineOfScrimmage + 10.0)

    # Game:
    def SetLineOfScrimmagePixels(self, pixels):
        self.lineOfScrimmage         = self.fieldPtr.ReverseScaleX(pixels) - 10.0
        self.lineOfScrimmageInPixels = pixels

    # Game:
    def UpdateLineOfScrimmage(self, yards):
        self.lineOfScrimmage         = self.lineOfScrimmage + yards
        self.lineOfScrimmageInPixels = self.fieldPtr.ScaleX(self.lineOfScrimmage + 10.0)

    # Game:
    # assumes line of scrimmage has been properly set
    def DrawLineOfScrimmage(self):
        x = self.lineOfScrimmageInPixels
        SafeDelete(self.canvas, self.lineOfScrimmageID)
        self.lineOfScrimmageID = self.canvas.create_line(x, 20, x, self.fieldPtr.GetHeight() - 20, fill='blue', dash=(4,4), width=3)

        x = self.fieldPtr.ScaleX(self.firstDownLine + 10.0)
        SafeDelete(self.canvas, self.firstDownLineID)
        self.firstDownLineID = self.canvas.create_line(x, 20, x, self.fieldPtr.GetHeight() - 20, fill='orange', dash=(4,4), width=3)
        self.firstDownLineInPixels = x

    # Game:
    # use this when player with mouse control (P) has transferred it to another player (Q)
    # argument is playerPtr of player 'Q'
    def TransferControl(self, playerPtr):
        assert(self.inControl != -1)
        self.players[self.inControl].ReleaseControl()
        playerPtr.AcquireControl()
        self.inControl = playerPtr.ID

    # Game:
    # the ball has been caught or intercepted or retrieved; what now?
    def DoCompletion(self, playerPtr):
        # print 'DOING COMPLETION!'
        # this makes this player make a dash for a TD
        if self.punted == True:
            if playerPtr.GetTeam() != self.offenseTeam:
                # print 'RUN TO THE ENDZONE'
                playerPtr.RunToEndzone()
            else:
                self.ballDownedAfterPunt = True
        else:
            # print 'RUN TO THE ENDZONE'
            playerPtr.RunToEndzone()

        # now, check if its an interception or not...
        if (playerPtr.team != self.offenseTeam) or self.punted == True:
            # ball acquired by other team
            if self.punted == False:
                self.PlaySong(['Intercepted-Anna.mp3', 'Intercepted-Maddy.mp3', 'Intercepted-Remzi.mp3'])

            # make sure that this doesn't result in a safety if it is an endzone catch
            if self.offenseTeam == 1:
                if playerPtr.GetX() < self.fieldPtr.leftTD:
                    self.notPastEndZoneLine = 1
            else:
                if playerPtr.GetX() > self.fieldPtr.rightTD:
                    self.notPastEndZoneLine = 1

            # keep track that an interception has occurred
            if self.punted == False:
                self.intercepted = True
                self.scoreboardPtr.LogText('  intercepted by ' + playerPtr.position)

            # make offense chase the lucky guy, change possession, tell defense to block? (XXX)
            # print '  -> Changing Possession'
            self.AlertPlayersOfInterceptionOrPuntReception(playerPtr)
            self.ChangePossession()
            return

        # XXX: this needs to be done only if control was in QB's hands... (only if YOUR team catches it)
        # XXX: only if on the same team!
        # XXX: assumes the only one to throw the ball is the QB ...
        self.scoreboardPtr.LogText('  caught by ' + playerPtr.position)
        if self.inControl != -1 and self.players[self.inControl].position == 'QB' and playerPtr.team == 0:
            self.TransferControl(playerPtr)
        # only if this is a FORWARD throw, and NOT AN INTERCEPTION!...
        if (self.offenseTeam == 0 and self.ballPtr.vx > 0) or (self.offenseTeam == 1 and self.ballPtr.vx < 0):
            self.AlertDefenseToChasePlayer(playerPtr)

    # Game: IsPractice()
    def IsPractice(self):
        return self.practiceMode

    # Game: 
    def GetPlayerByPosition(self, team, position):
        return self.playersByPosition[(team, position)]

    # Game: 
    def GetLineOfScrimmage(self):
        return self.lineOfScrimmage
       
    # Game: 
    def GetLineOfScrimmageInPixels(self):
        return ((self.lineOfScrimmage + 10.0) * self.fieldPtr.pixelsPerYard)
       
    # Game: 
    def GetMiddleOfField(self):
        return self.middleOfField
       
    # Game: 
    def GetMiddleOfFieldInPixels(self):
        return self.middleOfField * self.fieldPtr.pixelsPerYard

    # Game: 
    def InitLittlePlay(self):
        self.littlePlayers = []
        self.littleOffPlay = 0
        if self.practiceMode == True:
            self.littleOffMax  = 100
            self.littleDefMax  = 100
        else:
            self.littleDefMax  = self.playbookPtr[0].GetMaxDefensivePlay()
            self.littleOffMax  = self.playbookPtr[0].GetMaxOffensivePlay()
        self.littleDefPlay = 0
        self.DrawLittlePlay()
        

    # Game:
    def IncreaseLittlePlay(self):
        if self.offenseTeam == 0:
            if self.littleOffPlay < self.littleOffMax:
                self.littleOffPlay += 1
            self.scoreboardPtr.UpdateLittlePlay(self.littleOffPlay)
        else:
            if self.littleDefPlay < self.littleDefMax:
                self.littleDefPlay += 1
            self.scoreboardPtr.UpdateLittlePlay(self.littleDefPlay)
        self.UndrawLittlePlay()
        self.DrawLittlePlay()

    # Game:
    def DecreaseLittlePlay(self):
        if self.offenseTeam == 0:
            if self.littleOffPlay > 0:
                self.littleOffPlay -= 1
            self.scoreboardPtr.UpdateLittlePlay(self.littleOffPlay)
        else:
            if self.littleDefPlay > 0:
                self.littleDefPlay -= 1
            self.scoreboardPtr.UpdateLittlePlay(self.littleDefPlay)
        self.UndrawLittlePlay()
        self.DrawLittlePlay()

    # Game:
    def SelectLittlePlay(self):
        # a bit of a hack: avoid the race condition where the players are moving, and then the penalty occurs
        if self.state != self.StateWaitingToHike or self.scoreboardPtr.GetPlayClock() <= 3.0:
            self.scoreboardPtr.Flash('Play is Locked In!', 2000)
            return
        if self.offenseTeam == 0:
            self.playbookPtr[0].SetOffensivePlay(self.littleOffPlay)
        else:
            self.playbookPtr[0].SetDefensivePlay(self.littleDefPlay)
        self.SetupPlay()

    # Game:
    def LittleTranslate(self, location, absolute):
        (px, py) = (location[0], location[1])
        # next line here is a hack, should be improved
        (sx, sy) = (px * self.scoreboardPtr.pstScaleX / 3, py * self.scoreboardPtr.pstScaleY / 2.5)
        if absolute == True:
            return  (sx + self.scoreboardPtr.pstLOS, sy + self.scoreboardPtr.pstMOF)
        else:
            return  (sx, sy)
        
    # Game:
    def DrawLittlePlay(self):
        if self.autoPick == True:
            return
        if self.offenseTeam == 0:
            for pos in self.offensivePlayerPositions:
                # FORMATION
                form = self.formationPtr[0].GetOffensiveFormationByPlay(pos, self.littleOffPlay)
                tmp = form[0]
                if tmp['action'] == 'MoveToExact':
                    (ox, oy) = self.LittleTranslate(tmp['target'], True)
                    size     = 2.0
                    self.littlePlayers.append(self.canvas.create_oval(ox - size, oy - size, ox + size, oy + size, fill='orange', outline='orange'))
                else:
                    abort('EXPECTED MOVE-TO-EXACT')
                # PLAY
                behavior = self.playbookPtr[0].GetOffensivePlay(pos, self.littleOffPlay)
                (lx, ly) = (ox, oy)
                if pos == 'QB' or pos == 'TB' or pos == 'FB':
                    for move in behavior:
                        if move['action'] == 'MoveTo':
                            target = move['target']
                            (mx, my) = self.LittleTranslate(target, False)
                            (mx, my) = (mx + lx, my + ly)
                            self.littlePlayers.append(self.canvas.create_line(lx, ly, mx, my, fill='orange', width=1.0))
                            (lx, ly) = (mx, my)
        else:
            for pos in self.defensivePlayerPositions:
                # FORMATION
                form = self.formationPtr[0].GetDefensiveFormationByPlay(pos, self.littleDefPlay)
                # print 'DEFENSIVE THING for pos', pos, 'is', form
                tmp = form[0]
                if tmp['action'] == 'MoveToExact' and 'mode' in tmp and tmp['mode'] == 'cover':
                    (ox, oy) = self.LittleTranslate([tmp['target'][0], 0], True)
                elif tmp['action'] == 'MoveToExact':
                    (ox, oy) = self.LittleTranslate(tmp['target'], True)
                else:
                    abort('EXPECTED MOVE-TO-EXACT')
                size = 2.0
                self.littlePlayers.append(self.canvas.create_oval(ox - size, oy - size, ox + size, oy + size, fill='orange', outline='orange'))
                # PLAY
                behavior = self.playbookPtr[0].GetDefensivePlay(pos, self.littleDefPlay)
                (lx, ly) = (ox, oy)
                for move in behavior:
                    if move['action'] == 'MoveTo':
                        target = move['target']
                        (mx, my) = self.LittleTranslate(target, False)
                        (mx, my) = (mx + lx, my + ly)
                        self.littlePlayers.append(self.canvas.create_line(lx, ly, mx, my, fill='orange', width=1.0))
                        (lx, ly) = (mx, my)
                    elif move['action'] == 'Chase':
                        self.littlePlayers.append(self.canvas.create_oval(lx-1, ly-1, lx+1, ly+1, fill='red', outline=''))
                    elif move['action'] == 'Lateral':
                        self.littlePlayers.append(self.canvas.create_line(lx, ly-1, lx, ly+1, fill='red'))
                    elif move['action'] == 'Contain':
                        self.littlePlayers.append(self.canvas.create_line(lx-1, ly, lx+1, ly, fill='red'))
                    elif move['action'] == 'ZoneRegion':
                        self.littlePlayers.append(self.canvas.create_rectangle(lx-10, ly-10, lx+10, ly+10, fill='', outline='orange', dash=(2,2)))


    # Game:
    def UndrawLittlePlay(self):
        for item in self.littlePlayers:
            self.canvas.delete(item)

    #
    # Replay Engine
    #
    # Basically something to turn on and off replay
    # and to make it work when it is indeed on
    # 

    # Game:
    def ReplayStart(self):
        # make all the players and the ball on the field
        self.replayIDs = []
        for p in self.replayPlayers:
            (x, y) = p.replayBuffer[0]
            p.replayID = self.canvas.create_oval(x-p.size,y-p.size,x+p.size,y+p.size,fill=p.mainColor,outline=p.outlineColor)
        (x, y) = self.ballPtr.replayBuffer[0]
        self.replayBallID = self.canvas.create_oval(x-6,y-4,x+6,y+4,fill='yellow', outline='yellow')
        self.replayCounter = 0

    # Game:
    def ReplayEnd(self):
        # clean up by deleting everybody
        for p in self.replayPlayers:
            SafeDelete(self.canvas, p.replayID)
        SafeDelete(self.canvas, self.replayBallID)

    # Game:
    def ReplayCleanup(self):
        self.ReplayEnd()
        self.Pause()

    # Game:
    def ReplayAnimate(self):
        didSomething = False
        for p in self.replayPlayers:
            if self.replayCounter < len(p.replayBuffer):
                didSomething = True
                (x, y) = p.replayBuffer[self.replayCounter]
                self.canvas.coords(p.replayID, x-p.size,y-p.size,x+p.size,y+p.size)
        if self.replayCounter < len(self.ballPtr.replayBuffer):
            didSomething = True
            (x, y) = self.ballPtr.replayBuffer[self.replayCounter]
            self.canvas.coords(self.replayBallID, x-6, y-4, x+6, y+4)
            self.canvas.lift(self.replayBallID)
        self.replayCounter += 1
        if didSomething == False:
            self.doReplay = False
            self.root.after(2000, self.ReplayCleanup())

    # Game:
    def ReplayStartRecording(self):
        self.replayHaveRecorded = True
        self.replayPlayers = []
        for p in self.activePlayers:
            self.replayPlayers.append(p)
            p.StartRecording()
        self.ballPtr.StartRecording()

    # Game:
    def ReplayStopRecording(self):
        for p in self.activePlayers:
            p.StopRecording()
            
    # Game:
    def Replay(self):
        if self.replayHaveRecorded == False:
            return
        if self.paused == False:
            self.Pause()
        if self.doReplay == True:
            self.ReplayEnd()
            self.doReplay = False
        else:
            self.ReplayStart()
            self.doReplay = True

    # Game:
    def Pause(self):
        if self.doReplay == True:
            self.scoreboardPtr.Flash('Have to end replay first', 2000)
            return
        
        if self.paused == True:
            self.scoreboardPtr.ClockUnfreeze()
            for tid in self.replayThings:
                SafeDelete(self.canvas, tid)
            self.paused = False
        else:
            self.paused = True
            # could make this the same routines as those that originally drew the field (XXX)
            self.replayThings = []
            self.replayThings.append(self.canvas.create_rectangle(0,20,1400,645,fill='darkgreen', outline=''))
            for i in range(11):
                x = (i + 1) * (1400.0 / 12.0)
                self.replayThings.append(self.canvas.create_line(x, 20, x, 645, fill='white', width=2))
            self.replayThings.append(self.canvas.create_rectangle(0,645,1400,610,fill='white', outline=''))
            self.replayThings.append(self.canvas.create_text(700,30,text='Game Paused (hit \'p\' to unpause)', fill='orange'))
            self.scoreboardPtr.ClockFreeze()

    # 
    # Game: Animate()
    # 
    # This is a critical routine -- called every tick (30ms or so) to
    # update the state of the animation. Messing up things in here will
    # slow things down, so be careful.
    #
    # Also a good place to start if you really want to understand
    # what is going on in the program -- most everything is called
    # from here directly.
    # 
    def Animate(self):
        # new pause feature
        if self.paused == True:
            if self.doReplay == True:
                self.ReplayAnimate()
            self.root.after(self.timer, self.Animate)
            return

        # if frozen, don't do anything else
        if self.state == self.StateFrozen:
            self.root.after(self.timer, self.Animate)
            return

        # check for auto hike
        if self.state == self.StateWaitingToHike and self.practiceMode == False and (self.offenseTeam == 1 or self.autoPick == True):
            if self.scoreboardPtr.GetPlayClock() < self.computerHikeTime:
                self.DoHike()

        # always do this
        if self.state == self.StatePlayInAction or self.state == self.StateMoveToPosition:
            for p in self.activePlayers:
                done = p.CalculateMovement()
                if done == True:
                    self.doneCount = self.doneCount + 1
 
        # don't do this if we're waiting to hike
        if self.state == self.StatePlayInAction or self.state == self.StateMoveToPosition:
            for p in self.activePlayers:
                p.Move()

        # COLLISIONS: where all the problems are
        if self.state == self.StatePlayInAction:
            active = len(self.activePlayers)
            for i in range(0, active):
                for j in range(i+1, active):
                    p = self.activePlayers[i]
                    q = self.activePlayers[j]
                    distance = p.Dist(q)
                    p.SetDist(q, distance)
                    q.SetDist(p, distance)
                    diameter = (p.GetSize() + q.GetSize() + 1.0)

                    # XXX I don't think this is well done ...
                    if p.team == q.team:
                        if distance < (diameter * 1.4):
                            p.Avoid(q)
                            q.Avoid(p)
                        else:
                            p.Ignore(q)
                            q.Ignore(p)

                    # check for collisions ...
                    if distance <= diameter:
                        if p.Collide(distance, q) == True:
                            self.Tackled()

        # worth redrawing?
        if self.state == self.StatePlayInAction or self.state == self.StateMoveToPosition:
            for p in self.activePlayers:
                p.Redraw()
            tmp = self.ballPtr.UpdateMovement()
            if tmp == False:
                self.IncompletePass()
            # if ball has been downed
            if self.ballDownedAfterPunt == True:
                self.BallDowned()

        # if play is happening, do stuff like check for oob, td, and other fun things
        if self.state == self.StatePlayInAction:
            self.CheckForTouchdown()
            self.CheckForOutOfBounds()
            self.CheckForPastLineOfScrimmage()

        # CHECK STATE: SHOULD BE CHANGED?
        if self.state == self.StateMoveToPosition:
            if self.doneCount == len(self.activePlayers):
                self.doneCount = 0
                self.PrepareForPlay()

        # check for halftime here?
        if self.state == self.StateWaitingToHike:
            if self.halfOver == True:
                self.ResetToSecondHalf()
            if self.toggle == True:
                self.SwitchOffenseDefense()

        if self.state != self.StatePlayInAction:
            if self.gameOver == True:
                self.EndTheGame()
            if self.delayOfGame == True:
                self.DoDelayOfGame()

        # continue the animation ...
        self.root.after(self.timer, self.Animate)
    # END: Animate loop

    # 
    # Game: Animate2()
    # 
    # NOT USED YET
    # 
    def Animate2(self):
        # if frozen, don't do anything else
        if self.state == self.StateFrozen:
            self.root.after(self.timer, self.Animate)
            return

        # check for auto hike for computer
        if self.state == self.StateWaitingToHike and self.practiceMode == False and self.offenseTeam == 1:
            if self.scoreboardPtr.GetPlayClock() < self.computerHikeTime:
                self.DoHike()

        # always do this
        if self.state == self.StatePlayInAction or self.state == self.StateMoveToPosition:
            for p in self.activePlayers:
                done = p.CalculateMovement()
                if done == True:
                    self.doneCount = self.doneCount + 1
 
        # don't do this if we're waiting to hike
        if self.state == self.StatePlayInAction or self.state == self.StateMoveToPosition:
            for p in self.activePlayers:
                p.Move()

        # COLLISIONS: where all the problems are
        if self.state == self.StatePlayInAction:
            active = len(self.activePlayers)
            for i in range(0, active):
                for j in range(i+1, active):
                    p = self.activePlayers[i]
                    q = self.activePlayers[j]
                    distance = p.Dist(q)
                    p.SetDist(q, distance)
                    q.SetDist(p, distance)
                    diameter = (p.GetSize() + q.GetSize() + 1.0)

                    # XXX I don't think this is well done ...
                    if p.team == q.team:
                        if distance < (diameter * 1.4):
                            p.Avoid(q)
                            q.Avoid(p)
                        else:
                            p.Ignore(q)
                            q.Ignore(p)

                    # check for collisions ...
                    if distance <= diameter:
                        if p.Collide(distance, q) == True:
                            self.Tackled()

        # worth redrawing?
        if self.state == self.StatePlayInAction or self.state == self.StateMoveToPosition:
            for p in self.activePlayers:
                p.Redraw()
            tmp = self.ballPtr.UpdateMovement()
            if tmp == False:
                self.IncompletePass()

        # if play is happening, do stuff like check for oob, td, and other fun things
        if self.state == self.StatePlayInAction:
            self.CheckForTouchdown()
            self.CheckForOutOfBounds()
            self.CheckForPastLineOfScrimmage()

        # CHECK STATE: SHOULD BE CHANGED?
        if self.state == self.StateMoveToPosition:
            if self.doneCount == len(self.activePlayers):
                self.doneCount = 0
                self.PrepareForPlay()

        # check for halftime here?
        if self.state == self.StateWaitingToHike:
            if self.halfOver == True:
                self.ResetToSecondHalf()
            if self.toggle == True:
                self.SwitchOffenseDefense()

        if self.state != self.StatePlayInAction:
            if self.gameOver == True:
                self.EndTheGame()
            if self.delayOfGame == True:
                self.DoDelayOfGame()

        # continue the animation ...
        self.root.after(self.timer, self.Animate)
    # END: Animate2() loop

    # Game: ToggleOffenseDefense()
    # Use this to switch between offense and defense
    # Setting the flag here just makes it so that once players
    # are settled, they do the toggle
    def ToggleOffenseDefense(self):
        if self.practiceMode == True:
            self.toggle = True

    # Game: 
    def NumberPress(self, number):
        number = number - 1
        if self.offenseTeam == 1:
            number = number + 6
        
        if self.state == self.StateWaitingToHike or self.state == self.StatePlayInAction:
            if self.inControl == -1:
                self.players[number].AcquireControl()
                self.inControl = number
            else:
                self.players[self.inControl].ReleaseControl()
                if self.inControl != number:
                    self.players[number].AcquireControl()
                    self.inControl = number
                else:
                    self.inControl = -1

    # Game: 
    # this is for copying plays in the playbook
    # is the game controller the right place for this?
    # probably not
    def CopyPlay(self):
        self.playbookPtr[0].CopyPlay()
        self.formationPtr[0].CopyFormation()
        self.SetupPlay()

    # Game: 
    def PastePlay(self):
        self.playbookPtr[0].PastePlay()
        self.formationPtr[0].PasteFormation()
        self.SetupPlay()

    # Game: 
    def FlipPlay(self):
        self.playbookPtr[0].FlipPlay()
        self.formationPtr[0].FlipFormation()
        self.SetupPlay()

    # Game: 
    # this actually does the hike ...
    def DoHike(self):
        self.PlaySong(['Maddy-Hut.mp3'], True)

        # start replay
        self.ReplayStartRecording()

        # play is now in action
        self.state = self.StatePlayInAction

        # turn play clock off, turn other clock on
        if self.practiceMode == False:
            self.scoreboardPtr.StartClock()
        self.scoreboardPtr.StopPlayClock()

        # give ball to QB: should we animate this as a little throw?
        self.GetPlayerByPosition(self.offenseTeam, 'QB').AcquireBall()
        if self.inControl != -1:
            self.players[self.inControl].AcquireControl()
            self.inControlAtHike = self.inControl
        self.scoreboardPtr.LogText('Play %d In Action' % self.playCounter)
        self.playCounter = self.playCounter + 1

    # Game: 
    def Hike(self):
        # only allow hikes in practice mode or when you have the ball in a real game
        if self.practiceMode == True or self.offenseTeam == 0:
            self.DoHike()

    # Game: 
    def PassStart(self):
        # second press: throws a pass
        # XXX - need to fix this, or we can't throw the ball
        if self.hasBallBeenPassed == False and self.pastLineOfScrimmage == False and self.puntStart == False:
            self.passStart = True
            assert(self.ballPtr.DoesPlayerHaveBall() == True)
            self.ballPtr.PlayerWithBall().SlowDown()

    # Game: 
    def PassAccomplish(self):
        if self.passStart == True:
            assert(self.ballPtr.DoesPlayerHaveBall() == True)
            passer = self.ballPtr.PlayerWithBall()
            passer.SpeedUp()
            self.PassBall(passer, [self.controller.mouseX, self.controller.mouseY])
            passer.GetNextBehavior()
            self.passStart = False

    # Game:
    def PuntStart(self):
        if self.pastLineOfScrimmage == False and self.passStart == False:
            self.puntStart = True
            self.ballPtr.PlayerWithBall().SlowDown()

    # Game:
    def PuntAccomplish(self, x, y):
        if self.puntStart == True:
            punter = self.ballPtr.PlayerWithBall()
            punter.SpeedUp()
            self.PuntBall(punter, [x, y])
            punter.GetNextBehavior()
            self.punted    = True
            self.puntStart = False

    # Game: 
    # the ball or not ...
    def PreventHike(self):
        self.allowHike = False

    # Game: 
    def AllowHike(self):
        self.allowHike = True

    # Game: 
    def ShouldButtonWork(self):
        if self.inControl != -1:
            if self.ballPtr.DoesPlayerHaveBall() == False:
                return False
            if self.ballPtr.PlayerWithBall().GetID() == self.inControl:
                return True
        return False

    # Game: 
    def LeftButtonPress(self):
        if self.state == self.StatePlayInAction:
            if self.ShouldButtonWork() == True:
                self.PassStart()
            
    # Game: 
    def LeftButtonRelease(self):
        if self.state == self.StateWaitingToHike and self.allowHike == True:
            self.Hike()
        elif self.state == self.StatePlayInAction:
            if self.ShouldButtonWork() == True:
                self.PassAccomplish()

    # Game: 
    def RightButtonPress(self):
        if self.state == self.StatePlayInAction:
            if self.ShouldButtonWork() == True:
                self.PuntStart()
            
    # Game: 
    def RightButtonRelease(self):
        if self.state == self.StatePlayInAction:
            if self.ShouldButtonWork() == True:
                self.PuntAccomplish(self.controller.mouseX, self.controller.mouseY)

    # Game: 
    def PlaceBall(self):
        # also, place ball in right spot
        self.ballPtr.MoveInit((self.lineOfScrimmage + 10.0) * self.fieldPtr.pixelsPerYard, self.middleOfField * self.fieldPtr.pixelsPerYard)
        self.ballPtr.Redraw()

    # Game:
    # computes a score based on average yards per play and interceptions
    # if this play gets lots of yards and few ints --> 10
    # if it gets few yards and lots of ints        --> 1
    def ComputeScore(self, team, play, yardTotals, playTotals, intTotals):
        avg = 0
        if playTotals[(team, play)] > 0:
            avg = yardTotals[(team, play)] / playTotals[(team, play)]
        rawAvg = (avg / 5.0)
        if rawAvg > 10.0:
            rawAvg = 10
        rawInt = 0
        if playTotals[(team, play)] > 0:
            rawInt = (intTotals[(team, play)] * -25.0) / playTotals[(team, play)]
        if rawInt < -10:
            rawInt = -10
        score = rawAvg + rawInt
        if score < 1.0:
            score = 1.0
        if score > 10.0:
            score = 10.0
        score = int(score + 0.5)
        return score

    # Game: PickComputerPlay()
    # Uses a lottery based approach to find the best play for the computer to use
    # Very simply: weight each play based on yards/play and interceptions
    def PickComputerPlay(self, team):
        if self.offenseTeam == team:
            if self.down == 4:
                if self.offenseTeam == 0:
                    if self.lineOfScrimmage < 60:
                        print 'PUNT!'
                else:
                    if self.lineOfScrimmage > 40:
                        print 'PUNT'

        
        otherTeam = 1 - team
        if self.offenseTeam == otherTeam:
            # pick a defensive play
            lmax = self.playbookPtr[team].GetMaxDefensivePlay() + 1
        else:
            lmax = self.playbookPtr[team].GetMaxOffensivePlay() + 1

        # print 'Scores::'
        tickets = {}
        tmax    = 0
        for play in range(lmax):
            if self.offenseTeam == otherTeam:
                # defensive score
                score = 11 - self.ComputeScore(team, play, self.defYardTotals, self.defPlayTotals, self.defIntTotals)
            else:
                score = self.ComputeScore(team, play, self.offYardTotals, self.offPlayTotals, self.offIntTotals)
            # print '  play', play, '- score', score
            tickets[play] = score
            tmax         += score

        # generic lottery code
        winner = int(random.random() * tmax)
        # print 'Winner::', winner, '  tmax', tmax
        current = 0
        for play in range(lmax):
            current += tickets[play]
            if current > winner:
                current = play
                break
        if current >= lmax:
            current = lmax
        # print 'RealWinner::', current
        computerPlay = current

        # if this is the team on offense we are picking a play for,
        # we must also pick a time to hike the ball...
        # remember: computerHikeTime is the number of seconds left on the play clock
        if self.offenseTeam == team:
            self.computerHikeTime = int(random.random() * 3) + 7
            if self.scoreboardPtr.GetClockInSeconds() < 60:
                # print 'TEAM', team, 'LEFT', self.scoreboardPtr.GetLeftScore(), 'RIGHT', self.scoreboardPtr.GetRightScore()
                # if there isn't much time and it is tied or we are down, hike more quickly
                if (team == 0 and (self.scoreboardPtr.GetLeftScore() > self.scoreboardPtr.GetRightScore)) or (team == 1 and (self.scoreboardPtr.GetRightScore() > self.scoreboardPtr.GetLeftScore)):
                    print '-> SLOW HIKE'
                    self.computerHikeTime = int(random.random() * 3) + 7
            if self.computerHikeTime < 3:
                self.computerHikeTime = 3
            # print '-> HIKE TIME is', self.computerHikeTime

        # should this be done here?
        # how often should the computer call an audible?
        self.SetComputerPlay(team, computerPlay)

    # Game: 
    def SetComputerPlay(self, team, computerPlay):
        if self.practiceMode == False:
            if self.offenseTeam == 1 - team:
                # defensive play
                self.playbookPtr[team].SetDefensivePlay(computerPlay)
            else:
                self.playbookPtr[team].SetOffensivePlay(computerPlay)
        # little play stuff
        if team == 0:
            if self.offenseTeam == 0:
                self.littleOffPlay = computerPlay
                self.scoreboardPtr.UpdateLittlePlay(self.littleOffPlay)
            else:
                self.littleDefPlay = computerPlay
                self.scoreboardPtr.UpdateLittlePlay(self.littleDefPlay)
            self.UndrawLittlePlay()
            self.DrawLittlePlay()

    # Game: 
    # called after each 'MoveToExact' movement of players to their respective spots on the field
    def PrepareForPlay(self):
        self.notPastEndZoneLine = 0
        self.intercepted         = False
        self.punted              = False
        self.ballDownedAfterPunt = False
        self.lossOnDowns         = False
        self.delayOfGame         = False
        self.state               = self.StateWaitingToHike

        # start play clock, computer: pick play
        if self.practiceMode == False:
            self.scoreboardPtr.StartPlayClock()

        # get the new behavior for everyone
        for team in [0, 1]:
            for p in self.offensivePlayerPositions:
                self.playersByPosition[(team, p)].UpdateBehavior(self.playbookPtr[team].GetCurrentOffensivePlay(p))
            for p in self.defensivePlayerPositions:
                self.playersByPosition[(team, p)].UpdateBehavior(self.playbookPtr[team].GetCurrentDefensivePlay(p))

        # figure out which players should be inactive (if possession just changed)
        if self.doingBenchChange == True:
            self.activePlayers       = list(self.newlyActivePlayers)
            self.benchedPlayers      = list(self.newlyBenchedPlayers)
            self.newlyBenchedPlayers = []
            self.newlyActivePlayers  = []
            self.doingBenchChange    = False

        # hilite player that is in control
        if self.inControl != -1:
            p = self.players[self.inControl]
            p.AcquireControl()

        # only draw this for whomever is on offense
        if self.autoPick == False:
            if self.offenseTeam == 0 or self.practiceMode == True:
                self.playbookPtr[self.offenseTeam].DrawOffensiveBoxes()
            if self.offenseTeam == 1 or self.practiceMode == True:
                self.playbookPtr[self.defenseTeam].DrawDefensiveBoxes()
            for p in self.activePlayers:
                if p.team == 0 or self.practiceMode == True:
                    p.DrawPlay()

    # Game: 
    # assumes offense is still on offense, defense on defense
    def AlertPlayersOfInterceptionOrPuntReception(self, playerPtr):
        for position in self.offensivePlayerPositions:
            self.playersByPosition[(self.offenseTeam, position)].UpdateBehavior(behaviorList = [{'action':'Chase', 'target':playerPtr.GetPosition()}])

    # Game:
    def AlertAllThatBallHasBeenPunted(self):
        bt = self.ballPtr.GetTarget()
        for position in self.offensivePlayerPositions:
            self.playersByPosition[(self.offenseTeam, position)].UpdateBehavior(behaviorList = [{'action':'Chase', 'target':'ball'}])
        for position in self.defensivePlayerPositions:
            self.playersByPosition[(self.defenseTeam, position)].UpdateBehavior(behaviorList = [{'action':'Chase', 'target':'ball'}])
        
        
    # Game: 
    def AlertDefenseThatBallIsInTheAir(self):
        bt = self.ballPtr.GetTarget()
        for position in self.defensivePlayerPositions:
            self.playersByPosition[(self.defenseTeam, position)].UpdateBehavior(behaviorList = [{'action':'MoveTo', 'target':bt, 'mode':'absolute'}])

    # Game: 
    # they should start chasing now, yes?
    def AlertDefenseThatPlayerIsPastLineOfScrimmage(self):
        # XXX need to figure out which TEAM has ball
        playerPtr = self.ballPtr.PlayerWithBall()
        # ALERT ALL DEFENDERS ...
        for p in self.defensivePlayerPositions:
            self.playersByPosition[(self.defenseTeam, p)].UpdateBehavior(behaviorList = [{'action':'Chase', 'target':playerPtr.GetPosition()}])

    # Game: 
    def AlertDefenseToChasePlayer(self, playerPtr):
        for p in self.defensivePlayerPositions:
            self.playersByPosition[(self.defenseTeam, p)].UpdateBehavior(behaviorList = [{'action':'Chase', 'target':playerPtr.GetPosition()}])

    # Game: PuntBall()
    def PuntBall(self, player, target):
        # calculate things about target, etc.
        dx       = target[0] - player.GetX()
        dy       = target[1] - player.GetY()
        dist     = math.sqrt((dy*dy) + (dx*dx))

        # how far should the throw go (XXX - should have a punt rating)
        maxDist = self.fieldPtr.ScaleX(700.0)
        if dist > maxDist:
            # limit throw to how far this player can throw it
            dx = maxDist * (dx / dist)
            dy = maxDist * (dy / dist)
            dist = maxDist
            target[0] = player.GetX() + dx
            target[1] = player.GetY() + dy

        # could do some randomness here about punt accuracy
        puntTargetX = target[0]
        puntTargetY = target[1]

        # lose the ball
        punter = self.ballPtr.PlayerWithBall()
        punter.LoseBall()
        self.ballPtr.BeingPunted(punter, puntTargetX, puntTargetY)

        # tell everyone about the punt
        self.AlertAllThatBallHasBeenPunted()


    # Game: PassBall()
    # 
    # this routine is called when the button is released and thus the ball is passed
    # (or called by computer when it is doing the passing)
    # 
    def PassBall(self, player, target):
        # is this a FORWARD pass?
        forwardPass = False
        if self.offenseTeam == 0:
            if target[0] > player.GetX():
                forwardPass = True
        else:
            if target[0] < player.GetX():
                forwardPass = True
        if forwardPass == True:
            self.hasBallBeenPassed = True

        # calculate things about target, etc.
        dx       = target[0] - player.GetX()
        dy       = target[1] - player.GetY()
        dist     = math.sqrt((dy*dy) + (dx*dx))

        # how far should the throw go
        maxDist = self.fieldPtr.ScaleX(player.GetThrowMax())
        if dist > maxDist:
            # limit throw to how far this player can throw it
            dx = maxDist * (dx / dist)
            dy = maxDist * (dy / dist)
            dist = maxDist
            target[0] = player.GetX() + dx
            target[1] = player.GetY() + dy

        reduceSpeed = False
        if dist > (maxDist / 2.0):
            reduceSpeed = True
        
        # set trajectory
        if dist > maxDist:
            self.ballPtr.SetTrajectory(400.0)
        else:
            self.ballPtr.SetTrajectory(400.0 * (dist/maxDist))

        # how accurate should the throw be?
        accuracy = player.GetAccuracy()
        factor   = (random.random() * accuracy * dist/100.0)
        
        passTargetX = target[0] + factor
        passTargetY = target[1] + factor

        thrower = self.ballPtr.PlayerWithBall()
        thrower.LoseBall()
        self.ballPtr.BeingPassed(thrower, passTargetX, passTargetY, reduceSpeed)

        # find player who is target, and change their behavior
        minDist      = 1e6
        bestPosition = ''
        for position in self.offensivePlayerPositions:
            p = self.playersByPosition[(self.offenseTeam, position)]
            if p.eligibleReceiver == True:
                dx = passTargetX - p.GetX()
                dy = passTargetY - p.GetY()
                d  = (dx*dx) + (dy*dy)
                if d < minDist:
                    bestPosition  = position
                    bestPlayerPtr = p
                    minDist       = d
        assert(bestPosition != '')

        # here is the routine to call to do the adjustment
        if self.inControl != bestPlayerPtr.ID:
            bestPlayerPtr.MovePlayerToBallTarget(passTargetX, passTargetY)

        # finally, let the defense know, too (PERHAPS BELATEDLY?)
        if (self.offenseTeam == 0 and passTargetX > thrower.GetX()) or (self.offenseTeam == 1 and passTargetX < thrower.GetX()):
            self.AlertDefenseThatBallIsInTheAir()
        
    # Game: 
    def EndOfPlay(self, message):
        # print '** END OF PLAY! **'
        self.PlaySong(['Whistle.mp3'], True)

        # stop recording for replay
        self.ReplayStopRecording()

        # messages ...
        self.scoreboardPtr.LogText(message)
        self.state = self.StateFrozen

        # also, release control of ball carrier?
        if self.inControl != -1:
            self.players[self.inControl].ReleaseControl()
            if self.inControlAtHike != -1:
                self.inControl = self.inControlAtHike

        # also, just put ball on line of scrimmage
        if self.ballPtr.DoesPlayerHaveBall() == True:
            self.ballPtr.PlayerWithBall().LoseBall()
        self.ballPtr.WaitingForHike()

        # per-play state
        self.hasBallBeenPassed   = False
        self.pastLineOfScrimmage = False

    # Game: SetupPlay()
    # call this when a new play/formation has been chosen
    # this will set the game state to 'StateMoveToExact'
    # and then go about accomplishing the move
    # when done, the state will be 'StateWaitingToHike'
    # when done, PrepareForPlay() will be called ...
    def SetupPlay(self):
        self.state = self.StateMoveToPosition

        for t in [0, 1]:
            self.playbookPtr[t].UndrawOffensiveBoxes()
            self.playbookPtr[t].UndrawDefensiveBoxes()
        for p in self.activePlayers:
            p.UndrawPlay()

        # user controls offense: always set offensive players first as the defense can react to their positioning...
        for pos in self.offensivePlayerPositions:
            self.playersByPosition[(self.offenseTeam, pos)].UpdateBehavior(behaviorList = self.formationPtr[self.offenseTeam].GetCurrentOffensiveFormation(pos))
            self.playersByPosition[(self.defenseTeam, pos)].UpdateBehavior(behaviorList = self.formationPtr[self.defenseTeam].GetBenchFormation(pos))
        for pos in self.defensivePlayerPositions:
            self.playersByPosition[(self.defenseTeam, pos)].UpdateBehavior(behaviorList = self.formationPtr[self.defenseTeam].GetCurrentDefensiveFormation(pos))
            self.playersByPosition[(self.offenseTeam, pos)].UpdateBehavior(behaviorList = self.formationPtr[self.offenseTeam].GetBenchFormation(pos))

        # now, set play status appropriately?
        if self.offenseTeam == 0:
            play      = self.playbookPtr[0].GetOffensivePlayNumber()
            formation = self.playbookPtr[0].GetOffensiveFormationNumber()
            self.scoreboardPtr.UpdateLeftPlay(play)
            self.scoreboardPtr.UpdateLeftFormation(formation)
            if self.numTimesPlayUsed[(0, play)] > 0:
                self.scoreboardPtr.UpdateLeftYards('%.2f' % (float(self.yardsGainedPerPlay[(0, play)]) / self.numTimesPlayUsed[(0, play)]))
            else:
                self.scoreboardPtr.UpdateLeftYards('-')
            self.scoreboardPtr.UpdateLeftTimesRun(self.numTimesPlayUsed[(0, play)])
        else:
            self.scoreboardPtr.UpdateLeftPlay(self.playbookPtr[0].GetDefensivePlayNumber())
            self.scoreboardPtr.UpdateLeftFormation(self.playbookPtr[0].GetDefensiveFormationNumber())
            self.scoreboardPtr.UpdateLeftYards('-')
            self.scoreboardPtr.UpdateLeftTimesRun('-')
        self.scoreboardPtr.UpdateLeftTotalYards(self.yardsGained[0], self.yardsGainedByRunning[0], self.yardsGainedByPassing[0])
        self.scoreboardPtr.UpdateRightTotalYards(self.yardsGained[1], self.yardsGainedByRunning[1], self.yardsGainedByPassing[1])

        # DEBUG, and in practice mode:
        if self.practiceMode == True:
            if self.offenseTeam == 1:
                self.scoreboardPtr.UpdateRightPlay(self.playbookPtr[1].GetOffensivePlayNumber())
                self.scoreboardPtr.UpdateRightFormation(self.playbookPtr[1].GetOffensiveFormationNumber())
            else:
                self.scoreboardPtr.UpdateRightPlay(self.playbookPtr[1].GetDefensivePlayNumber())
                self.scoreboardPtr.UpdateRightFormation(self.playbookPtr[1].GetDefensiveFormationNumber())

        # just do this here...
        self.DoLittlePlayStuff()

    # Game:
    def DoLittlePlayStuff(self):
        if self.offenseTeam == 0:
            self.scoreboardPtr.UpdateLittlePlay(self.littleOffPlay)
        else:
            self.scoreboardPtr.UpdateLittlePlay(self.littleDefPlay)
        self.UndrawLittlePlay()
        self.DrawLittlePlay()
        
    # Game:
    def ChangePossession(self):
        self.offenseTeam = 1 - self.offenseTeam  # flip this
        self.defenseTeam = 1 - self.offenseTeam  # assign this to the opposite of the flipped result
        self.scoreboardPtr.UpdateBallOwner(self.offenseTeam)
        self.DoLittlePlayStuff()

    # Game: 
    def BenchChange(self):
        # remember who is about to become active, inactive, etc.
        self.doingBenchChange    = True
        self.newlyActivePlayers  = list(self.benchedPlayers)
        self.newlyBenchedPlayers = list(self.activePlayers)

        # have to get benched guys moving
        for player in self.benchedPlayers:
            self.activePlayers.append(player)

    # Game: 
    def HalfOver(self):
        self.halfOver = True

    # Game: 
    def GameOver(self):
        self.gameOver = True

    # Game: 
    def DelayOfGame(self):
        self.delayOfGame = True

    # Game: 
    def DoDelayOfGame(self):
        self.delayOfGame = False
        if self.practiceMode == False:
            self.scoreboardPtr.StopPlayClock()
            self.scoreboardPtr.StopClock()
            if self.offenseTeam == 0:
                if self.lineOfScrimmage < 10.0:
                    penalty = self.lineOfScrimmage / 2.0
                else:
                    penalty = 5.0
                self.UpdateLineOfScrimmage(-penalty)
            else:
                if self.lineOfScrimmage > 90.0:
                    penalty = (100.0 - self.lineOfScrimmage) / 2.0
                else:
                    penalty = 5.0
                self.UpdateLineOfScrimmage(penalty)
            if penalty < 5.0:
                self.scoreboardPtr.Flash('Delay of Game: Half the Distance, Repeat Down', 3000)
            else:
                self.scoreboardPtr.Flash('Delay of Game: Five Yard Penalty, Repeat Down', 3000)
            self.togo = self.togo + penalty
            self.scoreboardPtr.UpdateDownDistance(self.down, self.togo)
            self.DrawLineOfScrimmage()
            self.PlaceBall()
            self.SetupPlay()
            self.scoreboardPtr.ResetPlayClock()

    # Game: 
    def FirstDown(self):
        self.scoreboardPtr.LogText('First Down!')
        self.down = 1
        self.togo = 10
        if self.offenseTeam == 0:
            self.firstDownLine = self.lineOfScrimmage + 10.0
            if self.firstDownLine > 100.0:
                self.firstDownLine = 100.0
        else:
            self.firstDownLine = self.lineOfScrimmage - 10.0
            if self.firstDownLine < 0.0:
                self.firstDownLine = 0.0
        self.scoreboardPtr.UpdateDownDistance(self.down, self.togo)
        self.DrawLineOfScrimmage()

    # Game: 
    def AdvanceDownDistance(self):
        # ignore the plea to advance down + distance after an interception 
        # why? well, if you don't, it fucks up what happens after an interception on 4th down
        if self.intercepted == True or self.punted == True:
            return 
        
        self.down = self.down + 1

        if self.offenseTeam == 0:
            self.togo = self.firstDownLine - self.lineOfScrimmage
        else:
            self.togo = self.lineOfScrimmage - self.firstDownLine 

        if (self.offenseTeam == 0 and self.lineOfScrimmage > self.firstDownLine) or (self.offenseTeam == 1 and self.lineOfScrimmage < self.firstDownLine):
            if self.practiceMode == False:
                self.PlaySong(['Maddy-Firstdown.mp3'])
            self.FirstDown()
        else:
            if self.practiceMode == False:
                if self.down == 2:
                    self.PlaySong(['SecondDown-Anna.mp3', 'SecondDown-Dad.mp3', 'SecondDown-Maddy.mp3'])
                elif self.down == 3:
                    self.PlaySong(['ThirdDown-Anna.mp3', 'ThirdDown-Dad.mp3', 'ThirdDown-Maddy.mp3'])
                elif self.down == 4:
                    self.PlaySong(['FourthDown-Anna.mp3', 'FourthDown-Dad.mp3', 'FourthDown-Maddy.mp3'])
            
        self.scoreboardPtr.UpdateDownDistance(self.down, self.togo)
        # CHANGE OF POSSESSION
        if self.practiceMode == False and self.down > 4:
            self.lossOnDowns = True
            if self.ballPtr.DoesPlayerHaveBall() == True:
                self.ballPtr.PlayerWithBall().LoseBall()
            self.ChangePossession()

    # Game: 
    # toggle between offense and defense
    def SwitchOffenseDefense(self):
        self.toggle = False
        self.ChangePossession()
        self.BenchChange()
        self.InitLineOfScrimmage()
        self.DrawLineOfScrimmage()
        self.PlaceBall()
        self.SetupPlay()
        self.scoreboardPtr.UpdateControls()

    # Game:
    # this is a mess, but at least only called once :)
    def ResetToSecondHalf(self):
        if self.practiceMode == False:
            # XXX - this is too michigan specific
            if self.homeGame == True:
                self.PlayHomeSong()
            else:
                self.PlayAwaySong()

        self.halfOver = False
        self.scoreboardPtr.UpdateHalf(2)
        self.scoreboardPtr.Flash('Halftime... And The Band Played A March', 4000)
        self.scoreboardPtr.StopClock()
        self.scoreboardPtr.StopPlayClock()
        self.scoreboardPtr.ResetClock(self.halfLengthMins, self.halfLengthSecs)
        self.scoreboardPtr.ResetPlayClock()
        if self.homeGame == True:
            if self.offenseTeam == 0:
                self.offenseTeam = 1
                self.defenseTeam = 0
                self.BenchChange()
        else:
            if self.offenseTeam == 1:
                self.offenseTeam = 0
                self.defenseTeam = 1
                self.BenchChange()
        self.InitLineOfScrimmage()
        self.FirstDown()
        self.PlaceBall()
        self.SetupPlay()
        self.DoLittlePlayStuff()

    # Game: EndTheGame()
    def EndTheGame(self):
        self.state = self.StateFrozen
        left  = self.scoreboardPtr.GetLeftScore()
        right = self.scoreboardPtr.GetRightScore()
        self.scoreboardPtr.StopPlayClock()

        if self.flashed == True:
            return
        self.flashed = True
        if left > right:
            self.scoreboardPtr.Flash('Game Over: %s Wins,  %s - %s' % (self.leftTeam, left, right), 5000)
        elif left == right:
            self.scoreboardPtr.Flash('Game Over: A Tie, %s - %s ' % (left, right), 5000)
        else:
            self.scoreboardPtr.Flash('Game Over: %s Wins, %s - %s ' % (self.rightTeam, left, right), 5000)
        self.root.after(10000, self.ExitGame)

    # Game: ExitGame()
    def ExitGame(self):
        print 'Time: %.2f s' % (time.time() - self.initTime)
        print 'FinalScore: %s %s -- %s %s' % (self.leftTeam, self.scoreboardPtr.GetLeftScore(), self.rightTeam, self.scoreboardPtr.GetRightScore())
        if self.practiceMode == False:
            self.WriteHistoryFile(0, self.leftHistoryFile)
            self.WriteHistoryFile(1, self.rightHistoryFile)
        # print out dump of all plays
        
        exit(0)
        
    # Game: PlaySong()
    def PlaySong(self, songList, always=False):
        if self.practiceMode == True and always == False:
            return
        if self.sound == False:
            return
        sLen = len(songList)
        pick = int(random.random() * sLen)
        song = './Sounds-Kids/' + songList[pick]
        Popen(['/usr/bin/afplay', song])

    # Game: PlayHomeSong()
    def PlayHomeSong(self):
        if self.practiceMode == False:
            self.PlaySong([self.leftTeam+'.mp3'])

    # Game: PlayAwaySong()
    def PlayAwaySong(self):
        if self.practiceMode == False:
            self.PlaySong([self.rightTeam+'.mp3'])

    # Game: 
    def AfterTackled(self):
        self.CalculateStatistics(afterScore=False)
        # print 'AFTER TACKLED'
        if self.intercepted == True or self.lossOnDowns == True or self.punted == True:
            self.scoreboardPtr.StopClock()
            # print '  AT: DOING BENCH CHANGE!'
            self.BenchChange()
            self.FirstDown()
            # this takes care of the case where after a punt/intercept, you get tacked in the endzone -> touchback
            if (self.intercepted == True or self.punted == True) and self.notPastEndZoneLine == 1:
                x = self.GetLineOfScrimmageInPixels()
                if (self.offenseTeam == 0 and x < self.fieldPtr.leftTD) or (self.offenseTeam == 1 and x > self.fieldPtr.rightTD):
                    self.InitLineOfScrimmage()
                    self.DrawLineOfScrimmage()
        else:
            Nop()
            # print '  AT: **NOT** DOING BENCH CHANGE!'
            
        self.PlaceBall()
        if self.autoPick == True:
            self.PickComputerPlay(0)
        self.PickComputerPlay(1)
        self.SetupPlay()

    # Game: 
    def AfterScore(self):
        self.CalculateStatistics(afterScore=True)
        self.ChangePossession()
        # if you scored on an interception or punt return, no need to change who was offense/defense
        if self.intercepted == False and self.punted == False:
            self.BenchChange()
        self.InitLineOfScrimmage()
        self.DrawLineOfScrimmage()
        self.FirstDown()
        self.PlaceBall()
        if self.autoPick == True:
            self.PickComputerPlay(0)
        self.PickComputerPlay(1)
        self.SetupPlay()

    # Game: 
    def RecordOldInfo(self):
        self.oldLOS     = self.lineOfScrimmageInPixels
        self.oldPassed  = self.hasBallBeenPassed

    # Game: 
    def GetOffYardsPlaysInts(self, team, play):
        return (self.offYardTotals[(team, play)], self.offPlayTotals[(team, play)], self.offIntTotals[(team, play)])

    # Game: 
    def GetDefYardsPlaysInts(self, team, play):
        return (self.defYardTotals[(team, play)], self.defPlayTotals[(team, play)], self.defIntTotals[(team, play)])

    # Game: 
    def CalculateStatistics(self, afterScore):
        x    = self.oldLOS
        team = self.offenseTeam

        # no stats on punts
        if self.punted == True:
            return
        
        if self.intercepted == True:
            team = 1 - team

        if team == 0:
            pixelsGained = + self.lineOfScrimmageInPixels - x
        else:
            pixelsGained = - self.lineOfScrimmageInPixels + x 

        play         = self.playbookPtr[team].GetOffensivePlayNumber()
        formation    = self.playbookPtr[team].GetOffensiveFormationNumber()
        yardsGained  = self.fieldPtr.ReverseScaleX(pixelsGained)

        if self.intercepted == False:
            if yardsGained >= 0:
                self.scoreboardPtr.LogText('  Gained ' + '%0.2f' % yardsGained + ' yards')
            else:
                self.scoreboardPtr.LogText('  Lost ' + '%0.2f' % -yardsGained + ' yards')

        # print 'PLAYSTATS off:', team, 'play:', play, 'yards:', yardsGained, 'int?', BoolToBit(self.intercepted), 'pass?', BoolToBit(self.oldPassed)
        dteam = 1 - team
        dplay = self.playbookPtr[dteam].GetDefensivePlayNumber()

        # stats for making decisions on which plays to run
        if self.intercepted == False:
            self.offYardTotals[(team, play)]   += yardsGained
            self.defYardTotals[(dteam, dplay)] += yardsGained
        self.offPlayTotals[(team, play)]   += 1
        self.defPlayTotals[(dteam, dplay)] += 1
        self.offIntTotals[(team, play)]   += self.intercepted
        self.defIntTotals[(dteam, dplay)] += self.intercepted

        # print 'BEGIN OFF PLAY HISTOGRAM'
        for i in range(self.playbookPtr[team].GetMaxOffensivePlay() + 1):
            avg = 0
            if self.offPlayTotals[(team, i)] > 0:
                avg = self.offYardTotals[(team, i)] / self.offPlayTotals[(team, i)]
            rawAvg = (avg / 5.0)
            if rawAvg > 10.0:
                rawAvg = 10
            rawInt = 0
            if self.offPlayTotals[(team, i)] > 0:
                rawInt = (self.offIntTotals[(team, i)] * -25.0) / self.offPlayTotals[(team, i)]
            if rawInt < -10:
                rawInt = -10
            score = rawAvg + rawInt
            if score < 1.0:
                score = 1.0
            if score > 10.0:
                score = 10.0
            score = int(score + 0.5)
            # print '  ', i, score, '(' + str(rawAvg), str(rawInt) + ')', self.offYardTotals[(team, i)], self.offPlayTotals[(team, i)], '(', str(avg), ')', self.offIntTotals[(team, i)]
        #print 'END   OFF PLAY HISTOGRAM'
            
        #print 'BEGIN DEF PLAY HISTOGRAM'
        #for i in range(self.playbookPtr[dteam].GetMaxDefensivePlay() + 1):
        #    print '  ', i, self.defYardTotals[(dteam, i)], self.defPlayTotals[(dteam, i)], self.defIntTotals[(dteam, i)]
        #print 'END   DEF PLAY HISTOGRAM'
            
        # stats for the scoreboard
        self.yardsGained[team] += yardsGained
        if self.oldPassed == True:
            self.yardsGainedByPassing[team]   += yardsGained
        else:
            self.yardsGainedByRunning[team]   += yardsGained
        self.yardsGainedPerPlay[(team, play)] += yardsGained
        self.numTimesPlayUsed[(team, play)]   += 1

    def CheckForPastLineOfScrimmage(self):
        if self.ballPtr.DoesPlayerHaveBall() == False:
            return
        x = self.ballPtr.PlayerWithBall().GetX()
        if (self.offenseTeam == 0 and x > self.lineOfScrimmageInPixels) or (self.offenseTeam == 1 and x < self.lineOfScrimmageInPixels):
            if self.pastLineOfScrimmage == False:
                self.AlertDefenseThatPlayerIsPastLineOfScrimmage()
            self.pastLineOfScrimmage = True

    def BallDowned(self):
        self.ballDownedAfterPunt = False
        x = self.ballPtr.GetX()
        self.RecordOldInfo()
        self.SetLineOfScrimmagePixels(x)
        if (self.offenseTeam == 0 and x < self.fieldPtr.leftTD) or (self.offenseTeam == 1 and x > self.fieldPtr.rightTD):
            # touchback
            self.InitLineOfScrimmage()
            self.DrawLineOfScrimmage()
        if (self.offenseTeam == 1 and x < self.fieldPtr.leftTD) or (self.offenseTeam == 0 and x > self.fieldPtr.rightTD):
            # safety
            # XXX - this should go through a standard place where scores are recorded
            # like the routine AfterScore()
            if self.offenseTeam == 1:
                self.scoreboardPtr.UpdateRightTeamScore(2)
            else:
                self.scoreboardPtr.UpdateLeftTeamScore(2)
            self.InitLineOfScrimmage()
            self.DrawLineOfScrimmage()

        self.scoreboardPtr.Flash('Ball has been downed', 2000)
        self.EndOfPlay('Ball has been downed')
        self.scoreboardPtr.StopClock()
        self.scoreboardPtr.ResetPlayClock()
        self.root.after(600, self.AfterTackled)

    def CheckForOutOfBounds(self):
        if self.ballPtr.DoesPlayerHaveBall() == False:
            return
        p = self.ballPtr.PlayerWithBall()
        x = p.GetX()
        y = p.GetY()
        if x > self.fieldPtr.rightOut or x < self.fieldPtr.leftOut or y > self.fieldPtr.bottomOut or y < self.fieldPtr.topOut:
            if self.CheckForSafety() == True:
                return
            else:
                # yes, was out of bounds
                self.RecordOldInfo()
                self.SetLineOfScrimmagePixels(x)
                self.DrawLineOfScrimmage()
                self.AdvanceDownDistance()
                self.scoreboardPtr.Flash('Out of bounds!', 2000)
                self.EndOfPlay('Out of bounds')
                self.scoreboardPtr.StopClock()
                self.scoreboardPtr.ResetPlayClock()
                self.root.after(600, self.AfterTackled)

    def CheckForTouchdown(self):
        if self.ballPtr.DoesPlayerHaveBall() == False:
            return
        x = self.ballPtr.PlayerWithBall().GetX()
        if (self.offenseTeam == 0 and x > self.fieldPtr.rightTD) or (self.offenseTeam == 1 and x < self.fieldPtr.leftTD):
            if self.offenseTeam == 0:
                self.PlaySong(['Touchdown-Maddy.mp3'])
                self.root.after(3000, self.PlayHomeSong)
            elif self.offenseTeam == 1:
                self.root.after(3000, self.PlayAwaySong)

            self.RecordOldInfo()
            self.SetLineOfScrimmagePixels(x)
            self.scoreboardPtr.Flash('Touchdown!', 3000)
            self.EndOfPlay('Touchdown!')
            self.scoreboardPtr.StopClock()

            # scoreboard update
            if self.offenseTeam == 0:
                self.scoreboardPtr.UpdateLeftTeamScore(7)
            else:
                self.scoreboardPtr.UpdateRightTeamScore(7)

            self.scoreboardPtr.Flash('Score: %s - %s' % (self.scoreboardPtr.GetLeftScore(), self.scoreboardPtr.GetRightScore()), 3000)
            self.scoreboardPtr.ResetPlayClock()
            self.root.after(1200, self.AfterScore)

    # player must be tackled, or out of bounds ...
    # if they are, and they are in the endzone, SAFETY --> return TRUE
    def CheckForSafety(self):
        if self.ballPtr.DoesPlayerHaveBall() == False:
            return False
        if self.notPastEndZoneLine == 1:
            return False
        x = self.ballPtr.PlayerWithBall().GetX()
        if (self.offenseTeam == 0 and x < self.fieldPtr.leftTD) or (self.offenseTeam == 1 and x > self.fieldPtr.rightTD):
            self.RecordOldInfo()
            self.SetLineOfScrimmagePixels(x)
            self.scoreboardPtr.Flash('Safety!', 3000)
            self.EndOfPlay('Safety!')
            self.scoreboardPtr.StopClock()

            # scoreboard update
            if self.offenseTeam == 0:
                self.scoreboardPtr.UpdateRightTeamScore(2)
            else:
                self.scoreboardPtr.UpdateLeftTeamScore(2)

            self.scoreboardPtr.ResetPlayClock()
            self.root.after(1200, self.AfterScore)
            return True
        return False

    def Tackled(self):
        assert(self.ballPtr.DoesPlayerHaveBall() == True)
        if self.CheckForSafety() == True:
            return
        x = self.ballPtr.PlayerWithBall().GetX()
        self.RecordOldInfo()
        self.SetLineOfScrimmagePixels(x)
        self.DrawLineOfScrimmage()
        self.EndOfPlay('Tackled!')
        self.AdvanceDownDistance()
        self.scoreboardPtr.ResetPlayClock()
        self.root.after(600, self.AfterTackled)

    def BoxScore(self, str):
        print str

    def IncompletePass(self):
        self.RecordOldInfo()
        self.scoreboardPtr.Flash('Incomplete pass', 2000)
        self.EndOfPlay('Incomplete Pass')
        if self.offenseTeam == 0:
            self.BoxScore(self.leftTeam  + ' QB :: Incomplete Pass')
        else:
            self.BoxScore(self.rightTeam + ' QB :: Incomplete Pass')
        self.AdvanceDownDistance()
        self.scoreboardPtr.StopClock()
        self.scoreboardPtr.ResetPlayClock()
        self.root.after(600, self.AfterTackled)

    def PracticeFormationUp(self):
        if self.state != self.StateWaitingToHike:
            return
        if self.offenseTeam == 0:
            self.formationPtr[0].IncrementOffensiveFormation()
        else:
            self.formationPtr[0].IncrementDefensiveFormation()
        self.SetupPlay()

    def PracticeFormationDown(self, computer=False):
        if self.state != self.StateWaitingToHike:
            return
        if self.offenseTeam == 0:
            self.formationPtr[0].DecrementOffensiveFormation()
        else:
            self.formationPtr[0].DecrementDefensiveFormation()
        self.SetupPlay()

    def PracticePlaybookUp(self):
        if self.state != self.StateWaitingToHike:
            return
        if self.practiceMode == True:
            if self.offenseTeam == 0:
                self.playbookPtr[1].IncrementDefensivePlay()
            else:
                self.playbookPtr[1].IncrementOffensivePlay()
            self.SetupPlay()

    def PracticePlaybookDown(self):
        if self.state != self.StateWaitingToHike:
            return
        if self.practiceMode == True:
            if self.offenseTeam == 0:
                self.playbookPtr[1].DecrementDefensivePlay()
            else:
                self.playbookPtr[1].DecrementOffensivePlay()
            self.SetupPlay()

#
# MAIN GAME
#
parser = OptionParser()
parser.add_option('-t', '--timer', default=30, help='the frame rate of the animation', 
                  action='store', type='int', dest='timer')
parser.add_option('-L', '--team1', default='Michigan', help='who team1 is',
                  action='store', type='string', dest='team1')
parser.add_option('-R', '--team2', default='OhioState', help='who team2 is',
                  action='store', type='string', dest='team2')
parser.add_option('-A', '--away', default=False, help='is this an away game for team1?',
                  action='store_true', dest='awayGame')
parser.add_option('-s', '--sound', default=True, help='turn off the sounds',
                  action='store_false', dest='sound')
parser.add_option('-p', '--pick', default=False, help='should your side be automated too?',
                  action='store_true', dest='autoPick')
(options, args) = parser.parse_args()

if options.awayGame == True:
    homeGame = False
else:
    homeGame = True

r = Tk()
canvas = Canvas(r, width=1400, height=800)
canvas.pack()

f = Field(canvas=canvas, width=1400)
c = Controller(root=r, canvas=canvas, fieldPtr=f)
s = Scoreboard(root=r, canvas=canvas, fieldPtr=f, controller=c)
g = Game(root=r, canvas=canvas, controller=c, fieldPtr=f, scoreboardPtr=s, timer=options.timer,
         leftTeam=options.team1, rightTeam=options.team2, homeGame=homeGame, sound=options.sound,
         initTime=time.time(), autoPick=options.autoPick)
c.SetGamePtr(g)
c.SetScoreboardPtr(s)
s.SetGamePtr(g)

if options.sound == True:
    g.PlaySong(['Stadium-Crowd-Applause.caf'])

r.mainloop()

